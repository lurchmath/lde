{"version":3,"sources":["input-structure.litcoffee"],"names":["BasicInputModifier","Dependency","InputExpression","InputModifier","InputStructure","OutputStructure","Structure","extend","child","parent","ctor","this","constructor","key","hasProp","call","prototype","__super__","require","WorkerGlobalScope","importScripts","self","superClass","className","addSubclass","markDirty","yesOrNo","ref","alreadyStarted","feedback","type","dirty","instancesBeingInterpreted","instancesAlreadyStarted","clearAlreadyStarted","i","len","length","interpret","accessibles","childResults","scope","childArray","count","j","len1","node","result","insertChild","recursiveInterpret","allChildResults","childResult","children","index","originalAccessiblesLength","slice","push","concat","pop","trackIDs","feedbackData","subject","id","updateData","incomingConnection","results","source","sources","clearAttributesFromModifiers","getConnectionsIn","getConnectionSource","sort","a","b","isEarlierThan","updateDataIn","setCameFromModifier","attrKey","setAttribute","getCameFromModifier","getAttribute","attributes","setSingleValue","value","hasOwnProperty","addListItem","item","listSoFar","Array","addSetElement","element","asString","otherElement","setSoFar","JSON","stringify","dependencyContents","arguments","getContents","updateConnections","targetExpression","triple","actions","target","ref1","exports"],"mappings":"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","file":"input-structure.js","sourcesContent":["\n# Input Structures\n\nThe LDE module allows clients to construct input to that module as trees of\n`Structures`, but more specifically, trees of the subclass of `Structure`\ndefined in this module, `InputStructure`.\n\nThese have entirely different functionality than their cousins\n`OutputStructure` instances.  In short, these support interpretation while\n`OutputStructure`s support validation.  You can also think of the difference\nas this:  `InputStructure`s represent the syntax of what the user has\nexpressed to the client, and `OutputStructure`s represent the semantics into\nwhich we interpret that syntax.\n\n## Import modules\n\nImport the `Structure` class.  The following lines detect whether this\nis being used in Node.js or a WebWorker, or a WebWorker-like background\nthread within Node.js, and do the right thing in any case.\n\nIn the Worker cases, it is important not to call `importScripts` on the same\nmodule more than once from different files, or all manner of confusing logic\nerrors manifest at runtime, hence the checks below.\n\n    if require?\n        { Structure } = require './structure'\n        { OutputStructure } = require './output-structure'\n    else if WorkerGlobalScope?\n        if not WorkerGlobalScope.Structure?\n            importScripts 'structure.js'\n            importScripts 'output-structure.js'\n    else if self?.importScripts?\n        if not self.Structure?\n            importScripts 'release/structure.js'\n            importScripts 'release/output-structure.js'\n\n## Define the `InputStructure` class\n\n    class InputStructure extends Structure\n\nIn order for a hierarchy of structures to be able to be serialized and\ndeserialized, we need to track the class of each structure in the hierarchy.\nWe do so for this class with the following line of code.\n\n        className : Structure.addSubclass 'InputStructure', InputStructure\n\nMarking an `InputStructure` dirty means marking its entire ancestor chain\ndirty, because if a child's meaning has changed, that may impact the meaning\nof its parent, and so on up the chain.  If it is marked clean, this does not\nnecessarily propagate upwards.\n\nIf interpretation for this instance has already begun, then it is illegal to\nmark it dirty (or we might cause an infinite loop of reinterpretations).\nSubclasses should not do this, but in case they do, we police it here by not\nrespecting the request, and sending a feedback error.  For information on\ntypes of feedback, see [the API documentation page for the LDE](https://lurchmath.github.io/lde/site/api-lde/).\n\n        markDirty : ( yesOrNo = yes ) ->\n            if yesOrNo and @alreadyStarted\n                return @feedback type : 'dirty loop'\n            @dirty = yesOrNo\n            if yesOrNo then @parentNode?.markDirty()\n\n### Interpretation\n\nThe main purpose of `InputStructure`s is to be interpretable, converting the\nLDE's Input Tree (analogous to syntax) into its Output Tree (semantics).\nThe functions in this section support that purpose.\n\nWe will track which instance we are interpreting with a class variable.  It\nwill be a stack, in case one `interpret()` routine ever calls another\n(although this is not expected).  It will track the current set of running\n`interpret()` calls.  This will help us know, from anywhere in the LDE,\nwhich structures are currently being interpreted.  This variable is\nmaintained by the `recursiveInterpret()` routine defined further below.\n\n        instancesBeingInterpreted : [ ]\n\nWe will track which instances have started being interpreted with another\nclass variable.  This is important for preventing infinite loops in the\nrecursive interpretation process, should some instance try to mark as dirty\nanother instance whose interpretation has already begun (or even finished).\nThis, too, is managed by `recursiveInterpret()`, as well as the function\ndefined here.\n\n        instancesAlreadyStarted : [ ]\n        @clearAlreadyStarted : ->\n            for instance in InputStructure::instancesAlreadyStarted\n                delete instance.alreadyStarted\n            InputStructure::instancesAlreadyStarted = [ ]\n\nThe `interpret()` function defines how each subclass of `InputStructure`\nproduces one or more nodes in the Output Tree.  It returns zero or more\n`OutputStructure` instances, in an array.  We provide the following default\nimplementation that makes `InputStructure` instances behave like generic\nwrappers around their children.\n\nThe parameters have the following meanings:\n * `accessibles` - the list of `OutputStructure` instances in the Output\n   Tree accessible to the structures produced by this function\n * `childResults` - the list of results produced by interpreting the\n   children of this node (already computed), which will be a list of lists,\n   because each child's results are an array of `OutputStructure`s.\n * `scope` - the list of highest-level nodes in the Input Tree whose\n   interpretations will be placed in the scope of the interpretation of this\n   node, in the Output Tree\n\nSubclasses which override this must be sure to satisfy the following\nproperties.\n * Compute the result based *only* on the data in the first two parameters,\n   `accessibles` and `childResults`.  Do not read from other parts of the\n   Input or Output Trees, including the data in `scope`.\n * Mark another `InputStructure` dirty *only* if it is a descendant of one\n   of the structures in the `scope` array (the third parameter).\n\n\n        interpret : ( accessibles, childResults, scope ) ->\n            result = new OutputStructure() # plain vanilla wrapper node\n            count = 0\n            for childArray in childResults\n                result.insertChild node, count++ for node in childArray\n            [ result ] # must be an array even if it contains only one node\n\nThe `recursiveInterpret()` function defines how the Input Tree will be\ntraversed, making calls to the `interpret()` functions of its nodes as\nneeded to assemble the final interpretation of the entire Input Tree.  The\n`accessibles` and `scope` parameters default to empty (as they should when\nthis is run at the root of the Input Tree) but then in recursive calls have\nthe same meanings as documented above for the `interpret()` routine.  No\n`childResults` are passed in this case because the job of this routine is to\ndo the recursion that produces the recursive results from children.\n\n        recursiveInterpret : ( accessibles = [ ], scope = [ ] ) ->\n            # console.log 'recursiveInterpret for', @id()\n            originalAccessiblesLength = accessibles.length\n            allChildResults = [ ]\n\nThis loop does the actual recursion, to compute `allChildResults`.\n\n            for child, index in children = @children()\n\nFor the first child, the same list of accessibles for the parent applies to\nthat child, so we don't need to modify `accessibles`.  As the `scope`, we\npass the list of all subsequent siblings, in order.\n\n                childResult = child.recursiveInterpret accessibles,\n                    children[index+1...]\n                allChildResults.push childResult\n\nBut for later children, more things are accessible.  Specifically, anything\njust created by interpreting `child` should be accessible to its next\nsibling, so we update `accessibles` as follows, in preparation for the next\niteration of this loop through the children.\n\n                accessibles = accessibles.concat childResult\n\nNow that the recursion into children is complete, we will ask this structure\nto interpret itself in light of what's accessible to it.  To prepare for\nthat, we must first restore the `accessibles` array to its original content.\n\n            accessibles = accessibles[...originalAccessiblesLength]\n\nCall `interpret()` on this node, with all the correct parameters, mark this\nstructure as clean for interpretation, and return the result.  Push this\nonto the stack of instances being interpreted right before, and pop it right\nafter.\n\n            InputStructure::instancesBeingInterpreted.push @\n            InputStructure::instancesAlreadyStarted.push @\n            @alreadyStarted = yes\n            result = @interpret accessibles, allChildResults, scope\n            InputStructure::instancesBeingInterpreted.pop()\n\nAs we build the tree, we need to track the IDs used in it, so that nodes\nthat wish to form connections among descendants can do so.  Thus we must\nbegin tracking IDs as soon as new nodes are formed.  We do so here.\n\n            structure.trackIDs() for structure in result\n            @markDirty no\n            result\n\n### Feedback\n\nTo give feedback about a particular `InputStructure` instance, call the\n`feedback` method in that instance, which will delegate the work to the\nclass-level `feedback` method in the `Structure` class, but only after\nadding itself as the subject of the feedback data.  While that method's\ndefault implementation is a stub, it is overwritten by the LDE when\n[the Structure module](structure.litcoffee) is loaded into the LDE.\n\n        feedback : ( feedbackData ) ->\n            feedbackData.subject = @id()\n            Structure.feedback feedbackData\n\n## Define `InputExpression`s as a type of `InputStructure`\n\n`InputStructure`s come in two varieties, each represented by a subclass. The\nfirst is defined in this section:  An `InputExpression` is the type of\n`InputStructure` that the LDE will interpret into meaningful content in its\nOutput Tree.  In the next section, we define `InputModifier`s, which do not\nproduce nodes in the Output Tree, but just modify `InputExpression`\ninstances and thus impact how they produce nodes in the Output Tree.\n\n    class InputExpression extends InputStructure\n\nIn order for a hierarchy of structures to be able to be serialized and\ndeserialized, we need to track the class of each structure in the hierarchy.\nWe do so for this class with the following line of code.\n\n        className : Structure.addSubclass 'InputExpression', InputExpression\n\n### Expression-specific functionality\n\nDuring interpretation of the Input Tree, each expression will need to import\nfrom the modifiers connected to it any data that they wish to embed into the\nexpression, so that such data can be used to inform the expression's\ninterpretation.  We provide the following function for doing so.\n\nIt is required to process incoming connections in the order that the\nmodifiers appear in the Input Tree.  Thus we find all the modifiers first,\nthen sort them by their order in the tree, then embed the data.  The\n`clearAttributesFromModifiers()` function is documented later.\n\n        updateData : ->\n            @clearAttributesFromModifiers()\n            sources = [ ]\n            for incomingConnection in @getConnectionsIn()\n                source = @getConnectionSource incomingConnection\n                sources.push source if source instanceof InputModifier\n            sources.sort ( a, b ) ->\n                if a is b then 0 else if a.isEarlierThan b then -1 else 1\n            source.updateDataIn @ for source in sources\n\nWhen an `InputModifier` writes to an attribute of this object, we may want\nto mark the attribute as having come from a modifier.  This will help us\nprovide some convenience features to modifiers as they write to attributes.\nWe thus provide the following two functions that use internal attributes\n(ones beginning with underscore) to store metadata about an attribute.\n\n        setCameFromModifier : ( attrKey ) ->\n            @setAttribute \"_from modifier #{attrKey}\", yes\n        getCameFromModifier : ( attrKey ) ->\n            @getAttribute \"_from modifier #{attrKey}\"\n\nBefore the modification phase, it can be useful to delete everything that\nwas set by a modifier, so that modifiers can accumulate list or set data in\ntheir target without worrying about compounding what they added in the last\nrun of the modification phase.  Thus the following function guarantees that\nthe expression is in a pristine state, as far as modifier data is concerned.\n\n        clearAttributesFromModifiers : ->\n            for own key of @attributes\n                if key[...15] is '_from modifier '\n                    delete @attributes[key]\n                    delete @attributes[key[15...]]\n\n### Convenience functions for `InputModifier`s\n\nAn `InputModifier` may want to write a single value into its target\nexpression, but not overwrite any value already stored there.  To that end,\nwe have the following function.  It does exactly that, and also marks the\nwritten value as having come from a modifier.  Thus this function is\nintended to be called only by `InputModifier`s.  It returns true if it set\nthe value, and false if it did not because one was already there.  Because\nattributes written by modifiers are cleared at the start of every run of\n`updateData()`, the first modifier to attempt to write a single value will\nsucceed, and all others will fail.\n\n        setSingleValue : ( key, value ) ->\n            return no if @attributes.hasOwnProperty key\n            @setAttribute key, value\n            @setCameFromModifier key\n            yes\n\nAn `InputModifier` may want to append a single value to an array stored in\nits target expression, but not change any of the earlier values already\nstored in the array.  To that end, we have the following function.  It does\nexactly that, and also marks the array as having come from a modifier.  Thus\nthis function is intended to be called only by `InputModifier`s.  Because\nattributes written by modifiers are cleared at the start of every run of\n`updateData()`, the result at the end of a run of `updateData()` will be the\nlist of values appended by all connected modifiers that write to the array,\nin the order the modifiers appear in the document.\n\n        addListItem : ( key, item ) ->\n            listSoFar = @getAttribute key\n            if listSoFar not instanceof Array then listSoFar = [ ]\n            @setAttribute key, listSoFar.concat [ item ]\n            @setCameFromModifier key\n\nThis function is just like the previous, except it builds a set rather than\na list, and thus the order in which things are added is unimportant (and, of\ncourse, duplicates are not added twice).\n\n        addSetElement : ( key, element ) ->\n            asString = JSON.stringify element\n            setSoFar = @getAttribute key\n            @setCameFromModifier key\n            if setSoFar not instanceof Array then setSoFar = [ ]\n            for otherElement in setSoFar # is it already there?\n                return if asString is JSON.stringify otherElement\n            @setAttribute key, setSoFar.concat [ element ]\n\n## Define `Dependency` as a type of `InputExpression`\n\nThis class implements a foundational type of `InputExpression`, one that is\ngiven a list of `OutputExpression` instances loaded from a dependency file\nand whose `interpret()` routine places those instances directly into the\noutput tree.  It is used at the start of a document to represent all the\ndata imported from other documents on which that one depends (its\n\"dependencies\").\n\nIts constructor takes a list of `OutputExpression` instances and its\n`getContents()` member returns that same list.  That getter is used in the\n`interpret()` routine.\n\n    class Dependency extends InputExpression\n\nThe constructor stores the meaning loaded from dependency documents, which\nmust be a list of `OutputStructure` instances.  Any other arguments are\nignored.\n\n        constructor : ->\n            super()\n            @dependencyContents = \\\n                ( a for a in arguments when a instanceof OutputStructure )\n\nThe following method is just a getter for the data given to the constructor.\n\n        getContents : -> @dependencyContents\n\nInterpretation simply yields that list of contents.\n\n        interpret : ( accessibles, childResults, scope ) -> @getContents()\n\nIn order for a hierarchy of structures to be able to be serialized and\ndeserialized, we need to track the class of each structure in the hierarchy.\nWe do so for this class with the following line of code.\n\n        className : Structure.addSubclass 'Dependency', Dependency\n\n## Define `InputModifier`s as a type of `InputStructure`\n\nAs documented in the previous section, `InputModifier`s are the subclass of\n`InputStructure` that do not produce interpretations in the LDE's Output\nTree, but instead modify the interpretations of `InputExpression`s, which\ndo.\n\n    class InputModifier extends InputStructure\n\nIn order for a hierarchy of structures to be able to be serialized and\ndeserialized, we need to track the class of each structure in the hierarchy.\nWe do so for this class with the following line of code.\n\n        className : Structure.addSubclass 'InputModifier', InputModifier\n\nOne unique characteristic of modifiers is that they cannot contain other\nnodes as children.  Thus we alter the constructor so that when it calls the\nparent class's constructor, it does not pass on any arguments, and we\nredefine the `insertChild()` routine to do nothing.\n\n        constructor : -> super()\n        insertChild : ->\n\n### Modifier-specific functionality\n\nThe LDE guarantees that, before it interprets the Input Tree into the Output\nTree, it will run `updateConnections()` in every `InputModifier`.  This\ngives the modifier an opportunity to ensure that it is connected (using the\nordinary connections features built into all `Structure`s) to the correct\nset of `InputExpressions`, precisely those that it modifies.  Those\n`InputExpression`s will, during interpretation, then call the\n`updateDataIn()` functions in the modifiers attached to them, giving each\nsuch modifier a chance to impact the expression before it is interpreted.\n\nHere, we provide default implementations of both `updateConnections()` and\n`updateDataIn()`, which do nothing.  Subclasses of `InputModifier` can\nreimplement them to take actions appropriate to that subclass.\n\n        updateConnections : ->\n        updateDataIn : ( targetExpression ) ->\n\n## Define `BasicInputModifier`s as a type of `InputModifier`\n\nThis class implements the simplest (and probably most common) type of\n`InputModifier`, one that makes a series of calls to `setSingleValue()`,\n`addListItem()`, and/or `addSetElement()` in its target(s).  Thus its\nconstructor takes a set of key-value-type triples and stores them for later\nembedding in any target.  The \"type\" of the triple will be which kind of\nfunction should be used to insert it (single value, list item, set element),\nas the string name of that function (`\"setSingleValue\"`, `\"addListItem\"`,\nand `\"addSetElement\"`).\n\n    class BasicInputModifier extends InputModifier\n\nThe constructor that stores the set of triples, discarding any that don't\nmatch the format given above.\n\n        constructor : ->\n            super()\n            @actions = ( triple for triple in arguments \\\n                when triple.length is 3 and triple[2] in \\\n                [ 'setSingleValue', 'addListItem', 'addSetElement' ] )\n\nThe `updateDataIn()` method that just runs the functions described by the\ntriples.\n\n        updateDataIn : ( target ) ->\n            target[type] key, value for [ key, value, type ] in @actions\n\nIn order for a hierarchy of structures to be able to be serialized and\ndeserialized, we need to track the class of each structure in the hierarchy.\nWe do so for this class with the following line of code.\n\n        className : Structure.addSubclass 'BasicInputModifier',\n            BasicInputModifier\n\nNow if this is being used in a Node.js context, export the class we defined.\n\n    if exports?\n        exports.InputStructure = InputStructure\n        exports.InputExpression = InputExpression\n        exports.InputModifier = InputModifier\n        exports.BasicInputModifier = BasicInputModifier\n        exports.Dependency = Dependency\n"]}