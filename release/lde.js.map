{"version":3,"sources":["lde.litcoffee"],"names":["CurrentPhase","EventEmitter","Feedback","InputModifier","InputStructure","InputTree","LDEWorker","OutputStructure","OutputTree","Structure","ValidationQueue","WorkerPool","className","classObj","deserializeIfNeeded","expectedArgumentCount","feedback","functions","isInTheInputTree","isInTheOutputTree","key","numberOfCores","os","ref","ref1","value","hasProp","hasOwnProperty","require","WorkerGlobalScope","importScripts","self","getInputTree","getOutputTree","getInternalState","inputTree","toJSON","outputTree","setInternalState","state","untrackIDs","fromJSON","trackIDs","reset","children","attributes","id","structure","parent","jsonOrInputStructure","insertStructure","newChild","parentID","insertionIndex","disallowed","newInstance","instanceWithID","length","results","clearAttributes","apply","insertChild","deleteStructure","subtreeID","subtree","removeFromParent","replaceStructure","newTree","transferConnections","replaceWith","transferConnectionsTo","setStructureAttribute","setAttribute","insertConnection","sourceID","targetID","data","source","target","connect","removeConnection","getConnectionSource","getConnectionTarget","disconnect","setConnectionAttribute","setConnectionData","runModification","callback","updateAllConnections","node","child","i","len","updateConnections","runInterpretation","callJustChanged","maybeCorrect","removeConnectionsOutside","connection","j","k","len1","len2","ref2","ref3","getConnectionsIn","type","getConnectionsOut","clearAlreadyStarted","recursiveInterpret","Array","subject","details","error","justChanged","addEventListener","event","args","command","feedbackData","slice","call","indexOf","postMessage","payload","window","EventTarget","exports","addListener","dispatchEvent","Event","emit","setSize","size","worker","Math","max","available","push","pop","getAvailableWorker","numberAvailable","w","giveWorkerBack","dequeue","working","reboot","enqueue","priority","validate","this","structureBeingValidated","splice","whenReady","prototype","instanceJustChanged","instance","origin","getAttribute","lastCitationLookup","lookUpAllCitations","subclasses","Worker","setPhase","phase"],"mappings":"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","file":"lde.js","sourcesContent":["\n# Lurch Deductive Engine (LDE) Main File\n\nThis file imports all the other modules in this repository and exposes them\nthrough its `exports` member, so that clients can import just this one file\nand have access to all the functionality from all the source files in this\nrepository.\n\nImport the structure class; it will be exported to clients as well using\ncode at the end of this file.  The following lines detect whether this is\nbeing used in Node.js or a WebWorker, or a WebWorker-like background thread\nwithin Node.js, and do the right thing in any case.\n\n    if require?\n        os = require 'os'\n        { Structure } = require './structure'\n        { InputStructure, InputModifier } = require './input-structure'\n        { OutputStructure } = require './output-structure'\n        { LDEWorker } = require './worker'\n    else if WorkerGlobalScope?\n        importScripts 'structure.js'\n        importScripts 'input-structure.js'\n        importScripts 'output-structure.js'\n        importScripts 'worker.js'\n    else if self?.importScripts?\n        importScripts 'release/structure.js'\n        importScripts 'release/input-structure.js'\n        importScripts 'release/output-structure.js'\n        importScripts 'release/worker.js'\n\n## The Input Tree\n\nThe Input Tree is a global instance of the `InputStructure` class,\nrepresenting the content of the user's document as expressed to this module\nby the client.  We define the variable here and initialize it later.\n\n    InputTree = null\n\nClients should treat the global Input Tree as read-only, *except* through\nthe API provided in [the following section](#the-main-api).  But we provide\nthe following function for two reasons.\n\n 1. It is usable to *read* the Input Tree.  Although the client could also\n    use it to manipulate that tree, doing so violates the preconditions of\n    this module, and thus discards any behavior guarantees it provides.\n 2. As an important special case of the previous, it is usable in the unit\n    testing suite to verify that the API below is manipulating the tree\n    according to its specifications.\n\nThe following function returns the root of the Input Tree structure.\n\n    functions = { }\n    functions.getInputTree = -> InputTree\n\nClients can also replace the entire Input Tree in certain circumstances; see\ndetails in the following section.\n\n## The Output Tree\n\nThe Output Tree is a global instance of the `OutputStructure` class,\nrepresenting the content of the user's document as interpreted by this\nmodule from the Input Tree.  We define the variable here and initialize it\nlater.\n\n    OutputTree = null\n\nClients do not *ever* write to the Output Tree.  They can read from it,\nhowever, for the same two reasons as given for the Input Tree in the\nprevious section.  Thus the following function returns the root of the\nOutput Tree structure.\n\n    functions.getOutputTree = -> OutputTree\n\nClients may occasionally wish to replace the entire Input and Output Tree\npair.  This most likely happens when the state of the LDE is saved by\nfetching that pair and saving it to some filesystem, then later the state\nis restored by fetching the archived versions and putting them back into the\nLDE.\n\nBoth trees should be inserted at once, to keep things consistent, so we\nprovide a function for querying both trees at once, and another function for\nsetting both trees at once.  So that clients don't need to think about the\nOutput Tree at all, we just call the tree pair the LDE's \"internal state.\"\n\n    functions.getInternalState = ->\n        inputTree : InputTree.toJSON()\n        outputTree : OutputTree.toJSON()\n    functions.setInternalState = ( state ) ->\n        InputTree?.untrackIDs()\n        InputTree = Structure.fromJSON state.inputTree\n        InputTree.trackIDs()\n        OutputTree?.untrackIDs()\n        OutputTree = Structure.fromJSON state.outputTree\n        OutputTree.trackIDs()\n\nWe then use those functions to define a setup routine for the LDE's internal\nstate.  It clears out and re-initializes both the Input and Output Trees to\nbe empty.\n\nThe Input Tree gets the ID \"root\" and the Output Tree gets the ID \"OT root\".\nWe do not use the symmetric name \"IT root\" for the Input Tree's root,\nbecause the Input Tree is client-facing, and we do not wish to put on the\nclient the burden of using the \"IT\" prefix.  But we must distinguish the\ntwo, because these IDs are used by the global `Structure` class to\ndistinguish `Structure` instances, including those in both the Input Tree\nand the Output Tree.  Thus node IDs must be globally unique across both\ntrees.\n\nLater this module defines a pool of background thread workers and a queue of\nvalidation tasks for them to process.  This reset function also calls the\nreset function in both of those objects, to terminate all running work and\nclear out the queue of pending work, thus making the LDE at a completely\nfresh start.  We call them here with CoffeeScript's `?` syntax because the\nfirst time this routine is run, those objects are not fully set up, but all\nfuture times, they will be.\n\n    functions.reset = ->\n        functions.setInternalState\n            inputTree :\n                className : 'InputStructure'\n                children : [ ]\n                attributes : id : 'root'\n            outputTree :\n                className : 'OutputStructure'\n                children : [ ]\n                attributes : id : 'OT root'\n        WorkerPool?.reset?()\n        ValidationQueue?.reset?()\n\nUse the `reset()` function to initialize our internal state.\n\n    functions.reset()\n\n## Utilities\n\nWe create functions for use privately in this module, for verifying that a\nparticular structure is a descendant of the Input Tree or the Output Tree,\nrespectively.\n\n    isInTheInputTree = ( structure ) ->\n        while structure instanceof InputStructure\n            if structure is InputTree then return yes\n            structure = structure.parent()\n        no\n    isInTheOutputTree = ( structure ) ->\n        while structure instanceof OutputStructure\n            if structure is OutputTree then return yes\n            structure = structure.parent()\n        no\n\nWe create another function for use privately in this module, which takes a\nparameter that may be an `InputStructure` instance or a JSON serialization\nthereof.  It returns an `InputStructure` instance; in the first case by\ndoing nothing, and in the second case by attempting to deserialize it.\n\n    deserializeIfNeeded = ( jsonOrInputStructure ) ->\n        if jsonOrInputStructure instanceof InputStructure\n            jsonOrInputStructure\n        else\n            Structure.fromJSON jsonOrInputStructure\n\n## The Main API\n\nThis module presents to clients a seven-function API defined in this\nsection.  Each of these functions manipulates the global Input Tree.\n\n### Editing Structures in the Input Tree\n\nThe following insertion function deserializes the given structure from JSON,\nfinds the descendant of the Input Tree that has the given ID, and inserts\nthe deserialized version as one of its children, at the given index. If\nanything goes wrong in that process then it does nothing.  The ID must be\nthe ID of a Structure, as defined in that class (a string ID stored in the\nattribute \"id\").\n\nIt is also permitted for the first parameter to be an actual structure\ninstance rather than a JSON serialization of one.  This is primarily useful\nin very simple clients, where the LDE module will be loaded directly into\nthe client.\n\nIn either case, attributes whose keys begin with an underscore are not\npermitted; they are for internal use only.  Such attributes will be stripped\nbefore the structure is inserted.\n\nAll newly inserted structures and their descendants have all their IDs\ntracked.\n\n    functions.insertStructure = ( newChild, parentID, insertionIndex ) ->\n        if ( parent = Structure.instanceWithID parentID )? and \\\n           ( 0 <= insertionIndex <= parent.children().length ) and \\\n           ( isInTheInputTree parent ) and \\\n           ( newInstance = deserializeIfNeeded newChild )? and \\\n           ( newInstance instanceof InputStructure )\n            disallowed = ( key \\\n                for own key of newInstance.attributes when key[0] is '_' )\n            if disallowed.length > 0\n                newInstance.clearAttributes disallowed...\n            parent.insertChild newInstance, insertionIndex\n            newInstance.trackIDs()\n\nThe following function finds the descendant of the global Input Tree that\nhas the given ID and, assuming such a structure exists, removes it from its\nparent and stops tracking all IDs within it.\n\n    functions.deleteStructure = ( subtreeID ) ->\n        if ( subtree = Structure.instanceWithID subtreeID )? and \\\n           ( isInTheInputTree subtree ) and subtree isnt InputTree\n            subtree.removeFromParent()\n            subtree.untrackIDs()\n\nThe following function finds the descendant of the global Input Tree that\nhas the given ID and, assuming such a structure exists, deserializes the\nsecond argument as a Structure object and uses it to replace the original\nstructure in the Input Tree.  The deserialized version will have all of\nthe IDs in its hierarchy tracked.  This module will also stop tracking all\nIDs in the structure that was removed.\n\nIn either case, attributes whose keys begin with an underscore are not\npermitted; they are for internal use only.  Such attributes will be stripped\nbefore the structure is inserted.\n\nThis functionl, also, permits passing an actual `InputStructure` instance as\nthe second argument, rather than a serialized version.\n\n    functions.replaceStructure =\n    ( subtreeID, newTree, transferConnections = no ) ->\n        if ( subtree = Structure.instanceWithID subtreeID )? and \\\n           ( isInTheInputTree subtree ) and subtree isnt InputTree and \\\n           ( newInstance = deserializeIfNeeded newTree )? and \\\n           ( newInstance instanceof InputStructure )\n            disallowed = ( key \\\n                for own key of newInstance.attributes when key[0] is '_' )\n            if disallowed.length > 0\n                newInstance.clearAttributes disallowed...\n            subtree.replaceWith newInstance\n            if transferConnections\n                subtree.transferConnectionsTo newInstance\n            subtree.untrackIDs()\n            newInstance.trackIDs()\n\nThe following function finds the descendant of the global Input Tree that\nhas the given ID and, assuming such a structure exists, calls its member\nfunction for setting an attribute with the given key and value.  As per the\nrequirements of the `Structure.setAttribute` function, be sure to provide\nonly values that are amenable to `JSON.stringify`.\n\nThe key may not begin with an underscore; such key names are reserved for\ninternal use by the LDE.  If the given key begins with an underscore, this\nfunction does nothing.\n\n    functions.setStructureAttribute = ( subtreeID, key, value ) ->\n        if key[0] is '_' then return\n        if ( subtree = Structure.instanceWithID subtreeID )? and \\\n           isInTheInputTree subtree\n            if key is 'id' then subtree.untrackIDs no\n            if typeof value is 'undefined'\n                subtree.clearAttributes key\n            else\n                subtree.setAttribute key, value\n            if key is 'id' then subtree.trackIDs no\n\n### Editing Connections in the Input Tree\n\nThe following function adds a connection between two existing nodes in the\nInput Tree.  It accepts three parameters, the ID of the source node, the ID\nof the target node, and the JSON data for the connection.  That data must at\nleast contain an `id` field for the connection, which must be unique across\nthe entire Input Tree.  If any of these conditions are not satisfied, this\nfunction does nothing.  Otherwise, it creates the connection.\n\n    functions.insertConnection = ( sourceID, targetID, data ) ->\n        return no unless \\\n            ( source = Structure.instanceWithID sourceID ) and \\\n            ( target = Structure.instanceWithID targetID ) and \\\n            ( isInTheInputTree source ) and ( isInTheInputTree target )\n        Structure.connect source, target, data\n\nThe following function removes a connection between two nodes in the Input\nTree.  It takes just one parameter, the unique ID of the connection to\nremove.  It returns no if there is no such connection in the Input Tree, and\nyes if there is one; in the latter case, it removes it, otherwise it does\nnothing.\n\n    functions.removeConnection = ( id ) ->\n        return no unless \\\n            ( isInTheInputTree Structure.getConnectionSource id ) and \\\n            ( isInTheInputTree Structure.getConnectionTarget id )\n        Structure.disconnect id\n\nThe following function permits editing the attributes of a connection in the\nInput Tree.  It takes three parameters, a connection ID, a key, and a value.\nIf there is a connection in the Input Tree with the given unique ID, then\nthis function edits its attributes by assigning the given key-value pair,\noverwriting any with the same key that may have been there.  If the value is\nundefined (or omitted) then this function removes any old key-value pair\nwith the same key.  If any of the requirements given above are not\nsatisfied, the function does nothing.\n\n    functions.setConnectionAttribute = ( id, key, value ) ->\n        return no unless \\\n            ( isInTheInputTree Structure.getConnectionSource id ) and \\\n            ( isInTheInputTree Structure.getConnectionTarget id )\n        Structure.setConnectionData id, key, value\n\n### Phases of computation\n\nThe following sections define the modification, interpretation, and\nvalidation phases of LDE computation.  To track which one is currently\nhappening, we introduce the following global variable.  It defaults to null,\nmeaning none of those phases of computation are currently happening.\n\n    CurrentPhase = null\n\n### The Modification Phase\n\nIn the Modification Phase, the LDE runs the `updateConnections()` function\nin every `InputModifier` instance in the Input Tree, in no specified order.\nThe Modification Phase then hands off work to the Interpretation Phase,\nwhich always follows immediately after it.\n\nThis function is asynchronous, calling a callback when complete.\n\nAlthough it contains no asynchronous components in its current\nimplementation, we write its signature that way so that it can be made\nasynchronous later if we need to make it more efficient, and clients will\nnot need to change their use of it.\n\n    functions.runModification = ( callback ) ->\n        CurrentPhase = 'modification'\n        updateAllConnections = ( node ) ->\n            node.updateConnections() if node instanceof InputModifier\n            updateAllConnections child for child in node.children()\n        updateAllConnections InputTree\n        CurrentPhase = null\n        functions.runInterpretation callback\n\n### The Interpretation Phase\n\nIn the Interpretation Phase, the LDE runs the `recursiveInterpret()`\nfunction in the root of the Input Tree, replacing the Output Tree with the\nresult.  Like the above function, this one is asynchronous even though its\ncurrent implementation is synchronous.\n\nAfter interpretation, this function traverses the Output Tree and ensures\nthat every connection into or out of any node in it leads to another node in\nthe Output Tree.  (Any connection that leads outside that tree is removed.)\n\nFor the type of feedback this sends, see\n[the API documentation page for the LDE](https://lurchmath.github.io/lde/site/api-lde/).\n\n    functions.runInterpretation = ( callback ) ->\n        CurrentPhase = 'interpretation'\n\nFirst, define the function that ensures the Output Tree does not have\nconnections that lead outside of itself.  We will use this later if needed.\n\n        removeConnectionsOutside = ( node ) ->\n            for connection in node.getConnectionsIn()\n                if not isInTheOutputTree node.getConnectionSource connection\n                    node.disconnect connection\n                    node.feedback\n                        type : 'connection removed'\n                        id : connection\n            for connection in node.getConnectionsOut()\n                if not isInTheOutputTree node.getConnectionTarget connection\n                    node.disconnect connection\n                    node.feedback\n                        type : 'connection removed'\n                        id : connection\n            removeConnectionsOutside child for child in node.children()\n\nNext, produce the Output Tree, using the above routine and sending feedback\nif and when needed.\n\n        didReplaceOutputTree = no\n        InputStructure.clearAlreadyStarted()\n        try\n            maybeCorrect = InputTree.recursiveInterpret()\n            if maybeCorrect not instanceof Array\n                feedback\n                    subject : 'root'\n                    type : 'interpretation error'\n                    details : 'Interpretation did not produce an array.'\n            else if maybeCorrect[0] not instanceof OutputStructure\n                feedback\n                    subject : 'root'\n                    type : 'interpretation error'\n                    details : 'Interpretation did not produce an\n                        OutputStructure'\n            else\n                OutputTree = maybeCorrect[0]\n                removeConnectionsOutside OutputTree\n                feedback subject : 'root', type : 'updated LDE state'\n        catch e\n            feedback\n                subject : 'root'\n                type : 'interpretation error'\n                details : e\n        InputStructure.clearAlreadyStarted()\n\nFirst, we mark the interpretation phase as complete and call its callback.\nThen we go ahead and trigger any subsequent validation by visiting every\nnode of the Output Tree that is marked dirty and calling its `justChanged()`\nfunction.  This will often do nothing, but every node that is dirty for\nvalidation has to have a chance to react to that.\n\n        CurrentPhase = null\n        callback?()\n        callJustChanged = ( node ) ->\n            callJustChanged child for child in node.children()\n            node.justChanged?()\n        callJustChanged OutputTree\n\n### Event Listeners\n\nIf the LDE detects that it is being run in a background thread, it will set\nup listeners for messages from the parent thread.  These listeners handle\nmessages of eight types:\n\n * `insertStructure`, with three arguments, which calls the\n   `insertStructure` function defined above and sends no messages back\n * `deleteStructure`, with one argument, which calls `deleteStructure` and\n   sends no messages\n * `replaceStructure`, with two arguments, which calls `replaceStructure`\n   and sends no messages\n * `setStructureAttribute`, with three arguments, which calls\n   `setStructureAttribute` and sends no messages\n * `insertConnection`, with three arguments, which calls the\n   `insertConnection` function defined above and sends no messages back\n * `removeConnection`, with one argument, which calls the\n   `removeConnection` function defined above and sends no messages back\n * `setConnectionAttribute`, with three arguments, which calls the\n   `setConnectionAttribute` function defined above and sends no messages\n   back\n * `getInputTree`, with zero arguments, which sends back a message\n   containing the JSON serialized form of the document, as fetched using the\n   `getInputTree` function defined above\n * `getOutputTree`, with zero arguments, which sends back a message\n   containing the JSON serialized form of the document, as fetched using the\n   `getOutputTree` function defined above\n * `getInternalState`, with zero arguments, which sends back a message\n   containing both of the previous two results (Input and Output Trees)\n * `setInternalState` can be passed a single argument, a previous response\n   to the `getInternalState` query, to restore the Input and Output Trees\n   to the state they were in at the time of that query.\n * `reset` takes no parameters and calls `setInternalState` with blank Input\n   and Output Trees.\n\n\n    if WorkerGlobalScope? or self?.importScripts?\n\nHere are the numbers of arguments we accept for each message we accept.\nEach is an array, any number in the array is acceptable.\n\n        expectedArgumentCount =\n            insertStructure : [ 3 ]\n            deleteStructure : [ 1 ]\n            replaceStructure : [ 2, 3 ]\n            setStructureAttribute : [ 2, 3 ]\n            insertConnection : [ 3 ]\n            removeConnection : [ 1 ]\n            setConnectionAttribute : [ 2, 3 ]\n            getInputTree : [ 0 ]\n            getOutputTree : [ 0 ]\n            getInternalState : [ 0 ]\n            setInternalState : [ 1 ]\n            reset : [ 0 ]\n            runModification : [ 0 ]\n\nMessages received expect data arrays of the form `[ command, args... ]`.\n\n        self.addEventListener 'message', ( event ) ->\n            [ command, args... ] = event.data\n\nAnything with the right number of arguments is passed on to the\ncorresponding function.  That function may or may not do anything, depending\non whether the data is in the correct form.\n\n            if args.length in ( expectedArgumentCount[command] ? [ ] )\n                if command is 'getInputTree'\n                    self.postMessage\n                        type : 'getInputTree'\n                        payload : functions.getInputTree().toJSON()\n                else if command is 'getOutputTree'\n                    self.postMessage\n                        type : 'getOutputTree'\n                        payload : functions.getOutputTree().toJSON()\n                else\n                    functions[command] args...\n\nWe also add the following function that is useless in production, but is\nuseful in testing.  It transmits feedback about any given node in the\nInput Tree.\n\n            if command is 'sendFeedback'\n                [ id, feedbackData ] = args\n                subject = Structure.instanceWithID id\n                if subject?.feedback?\n                    subject.feedback feedbackData\n                else\n                    self.postMessage \"No such Structure: #{id}\"\n\n## Feedback\n\nIf we have been loaded in node.js or the browser, create a global feedback\nmechanism called `Feedback`, an instance of `EventTarget` or `EventEmitter`,\ndepending on whether this is node.js or the browser.\n\n    if window? and EventTarget?\n        Feedback = window.Feedback = new EventTarget() # browser\n    if require? and exports?\n        EventEmitter = require 'events'\n        Feedback = exports.Feedback = new EventEmitter() # node\n        Feedback.addEventListener = Feedback.addListener # make API same\n\nWe also create a function global to this module that implements the sending\nof feedback to our context.  In node.js or the browser, we emit an event\nfrom the `Feedback` object just created.  If we are running in a `WebWorker`\n(or node.js's equivalent of one) then we post a message to our parent\ninstead.\n\n    feedback = ( feedbackData ) ->\n        if Feedback?.dispatchEvent?\n            event = new Event 'feedback'\n            event.data = feedbackData\n            Feedback.dispatchEvent event\n        else if Feedback?.emit?\n            Feedback.emit 'feedback', feedbackData\n        else if self?.postMessage?\n            self.postMessage\n                type : 'feedback'\n                payload : feedbackData\n\nInstall that function in the `Structure` class, overriding the stub class\nmethod that module installs in itself.\n\n    Structure.feedback = feedback\n\n## Validation workers\n\nThe LDE keeps a global pool of `LDEWorker` instances that wait to be used\nfor validating the Output Tree.  These are classified as available or\nunavailable, and one can ask the pool to give it an available worker, thus\nmarking it unavailable, and return it when done, thus marking it available\nagain.  One can also set the size of the pool.\n\nNote that none of these functions verify that the worker is or is not\nrunning.  We require that clients only return a worker to the pool if it is\ndone running.  If they wish to terminate its work and return it once it has\nreset itself, they can call `myWorker.reboot` and pass a callback that\napplies `returnAvailableWorker`, because the reboot guarantees that the\nworker is ready for use when its callback is called.\n\n    WorkerPool = [ ]\n    WorkerPool.setSize = ( size ) ->\n        size = Math.max size, 1\n        while WorkerPool.length < size\n            worker = new LDEWorker()\n            worker.available = yes\n            WorkerPool.push worker\n        # WorkerPool = WorkerPool[...size] would discard inner funcs., so:\n        while WorkerPool.length > size then WorkerPool.pop()\n    WorkerPool.getAvailableWorker = ->\n        for worker in WorkerPool\n            if worker.available\n                worker.available = no\n                return worker\n        undefined\n    WorkerPool.numberAvailable = ->\n        ( w for w in WorkerPool when w.available ).length\n\nWhenever a worker becomes available, we call the dequeueing function defined\nin the next section, below, in case it has work that it wants to assign to\nthat worker.  Also, if this is the final worker to be given back, and the\nvalidation queue has nothing left to be done in it, we emit feedback saying\nthat validation is complete.\n\n    WorkerPool.giveWorkerBack = ( worker ) ->\n        worker.available = yes\n        if ValidationQueue.length > 0\n            ValidationQueue.dequeue()\n        else if WorkerPool.numberAvailable() is WorkerPool.length\n            feedback\n                subject : 'OT root'\n                type : 'validation complete'\n                details : 'The validation phase just completed.'\n\nWe write a function to compute the number of cores available on the user's\nmachine, either in Node.js or the browser, then set the pool size to be one\nless than the number of cores (so that we leave one core for the UI thread).\n\n    numberOfCores = ->\n        navigator?.hardwareConcurrency ? os?.cpus?()?.length ? 1\n    WorkerPool.setSize numberOfCores() - 1 # setSize caps this below at 1\n\nWe will also want to be able to reset the validation phase, meaning that all\nvalidation should stop and the queue be emptied without any further work\nbeing assigned to workers.  This is useful if the user discards all their\nwork in the client and wishes to start a new document, for example.\n\nWe split this task into two parts: stopping all workers and emptying the\nqueue.  Stopping all workers happens with the following function; emptying\nthe queue happens with a function defined in the next section.\n\nNote that this function does *not* call `giveWorkerBack()`, so that one\nmight call `reset()` here and then in the validation queue, in either order.\nIf we used `giveWorkerBack()` it would start validating the next job\nimmediately, which is not the intended result.  But calling this function\nwithout emptying the validation queue will result in pausing all work\nwithout emptying that queue.\n\n    WorkerPool.reset = ->\n        working =\n            ( worker for worker in WorkerPool when not worker.available )\n        for worker in working\n            worker.reboot()\n            worker.available = yes\n\n## Validation priority queue\n\nThis module tracks a list of the `OutputStructure` instances that are\nawaiting validation.  Validation will be run on these using the workers from\nthe pool just defined.  We let clients enqueue structures to be validated,\ntogether with priorities, which should be numbers (and default to zero).\nThis feature permits clients to prioritize things the users care about (such\nas the work that's currently visible on the user's screen) above other\nthings (such as work on which the user is not currently focusing).\n\n    ValidationQueue = [ ]\n\nClients may enqueue any `OutputStructure` with a validate routine.  We keep\nthe queue in order from lowest-priority items at the beginning of the array\nto highest-priority items at the end of the array.  Each item is simply an\nobject with `structure` and `priority` fields.\n\n    ValidationQueue.enqueue = ( structure, priority = 0 ) ->\n        return unless \\\n            ( structure instanceof OutputStructure ) and \\\n            ( typeof structure.validate is 'function' )\n\nIf the structure is already enqueued for processing, this function should do\nnothing.  We loop here to check that.\n\n        for record in @ then if record.structure is structure then return\n\nIf the structure is currently being processed by a worker, we must first\nreboot that worker before re-enqueueing this worker for validation.\n\n        for worker in WorkerPool\n            if worker.structureBeingValidated is structure\n                delete worker.structureBeingValidated\n                worker.reboot()\n                WorkerPool.giveWorkerBack worker\n\nWe can safely insert.\n\n        insertionIndex = 0\n        while ( insertionIndex < ValidationQueue.length ) and \\\n              ( ValidationQueue[insertionIndex].priority < priority )\n            insertionIndex++\n        ValidationQueue.splice insertionIndex, 0,\n            structure : structure\n            priority : priority\n\nWhenever we add an item to the queue, we also immediately attempt to\ndequeue, because it may be the case that there is a worker available to\nhandle the processing of the structure we just added to the queue.  (More\nimportantly, it may be the case that no validation is currently running, and\nthe dequeue function will start it up.)\n\n        ValidationQueue.dequeue()\n\nClients may dequeue the highest-priority structure for processing provided\nthat (a) there is an item on the queue to dequeue, (b) we are not in the\nmiddle of interpretation or validation, and (c) there is a free worker in\nthe worker pool to which we can assign the job of validating the structure\nthat would be dequeued.\n\nThis function automatically dequeues the structure, runs its validation\nroutine, passes that validation routine the worker that can be used in\nbackground processing, and sets the validation routine's callback to be one\nthat puts the worker back on the pool of available workers.\n\nThus validation routines will typically assign a job to the worker, get the\nresult, and then call the callback.  Very quick validation routines can just\ndo their work and call the callback, ignoring the worker.\n\n    ValidationQueue.dequeue = ->\n        return unless \\\n            ( CurrentPhase is null ) and \\\n            ( ValidationQueue.length > 0 ) and \\\n            ( worker = WorkerPool.getAvailableWorker() )?\n        structure = ValidationQueue.pop().structure\n        worker.whenReady ->\n            worker.structureBeingValidated = structure\n            structure.validate worker, ->\n                delete worker.structureBeingValidated\n                WorkerPool.giveWorkerBack worker\n\nAs stated in the previous section, resetting the validation phase means all\nvalidation should stop and the queue be emptied without any further work\nbeing assigned to workers.\n\nWe split this task into two parts: stopping all workers and emptying the\nqueue.  Stopping all workers happens with the `reset()` function in the\n`WorkerPool` object.  Emptying the queue happens here.\n\n    ValidationQueue.reset = ->\n        ValidationQueue.splice 0, ValidationQueue.length\n\n## Handling Output Tree changes\n\nThe interpretation phase completes by calling `justChanged()` in all nodes\nof the Output Tree that were changed.  The default implementation just\ndefers computation to a non-existant class method `instanceJustChanged()`,\nwhich we can override here to use the validation queue we just defined.\n\nIf the structure has no validation routine, do nothing.  If its origin\n`InputStructure` has validation priority null, do nothing (because that\nmeans \"skip this\").  Othwerise, enqueue it for validation with the\nappropriate priority obtained from its origin (defaulting to zero).  But\nbefore enqueueing for validation, look up and store all its citations for\nlater reference and comparison.  (We do this before enqueueing in case its\nvalidation routine is synchronous and might be called immediately upon\nenqueueing.)\n\n    OutputStructure::instanceJustChanged = ( instance ) ->\n        return unless typeof instance.validate is 'function'\n        priority = @origin?.getAttribute 'validation priority'\n        return if priority is null\n        if typeof priority isnt 'number' then priority = 0\n        instance.lastCitationLookup = instance.lookUpAllCitations()\n        ValidationQueue.enqueue instance, priority\n        instance.feedback type : 'validation queued'\n\n## Module exports\n\nExpose those functions and classes that clients may access.\n\n    if exports?\n        for own className, classObj of Structure::subclasses\n            exports[className] = classObj\n        exports[key] = functions[key] for own key, value of functions\n        exports.WorkerPool = WorkerPool\n        exports.ValidationQueue = ValidationQueue\n        exports.Worker = LDEWorker\n\nWe also expose the following function only for testing purposes.  It lets\nthe client set the current phase (modification, interpretation, validation)\nof the LDE, which ordinarily clients should never touch.  This is here only\nfor use in the testing suite.\n\n        exports.setPhase = ( phase ) -> CurrentPhase = phase\n"]}