////////////////////////////////////////////////////////////////////////////
//
// Propositional Logic Lib
//

// Global Constants - we don't want any of these to be metavariables
Declare and or â‡’ â‡” Â¬ â†’â†

Rules:
{ 
  
  ////////////////////////////////
  // ND Propositional Logic Axioms
  ////////////////////////////////
  :{ {W V}  â‰¡  W and V }                // and+
  :{ {:W V} â‰¡  Wâ‡’V }                    // â‡’
  :{ { {:W V} {:V W} } â‰¡ Wâ‡”V }          // â‡”
  :{ :W  (W or V) (V or W) }            // or+
  cases> 
  :{ :(W or V) :{:W U} :{:V U}  U }     // or-
  :{ :{:W â†’â†}  Â¬W }                     // Â¬+
  :{ :{:Â¬W â†’â†}  W }                     // Â¬-
  :{ :W :Â¬W â†’â† }                        // â†’â†+

}
////////////////////////////////////////////////////////////////////////////
// Predicate Logic Lurch Lib
//

// Global Constants - we don't want any of these to be metavariables
Declare âˆ€ âˆƒ âˆƒ! =

////////////////////////////////
// ND Predicate Logic Axioms
////////////////////////////////
Rules:  
{
  
  :{ :(âˆ€x.ğœ†P(x))  ğœ†P(t) }               // âˆ€-
  :{ :{ :Let x  ğœ†P(x) }  âˆ€y.ğœ†P(y) }     // âˆ€+
  :{ :(âˆƒx. ğœ†P(x)) ğœ†P(c) for some c }    // âˆƒ-
  :{ :ğœ†P(t) âˆƒx.ğœ†P(x) }                  // âˆƒ+
  :{ :x = y  :ğœ†P(x) ğœ†P(y) }             // substitution
  :{ W = W }                            // reflexive =
  :{ (âˆƒ!x.ğœ†P(x)) â‰¡                      // âˆƒ!
     (âˆƒx.ğœ†P(x) and (âˆ€y.ğœ†P(y) â‡’ y = x)) 
   }                                    
} 

//////////////////////////////////
// ND Propositional Logic Theorems
//////////////////////////////////

// We comment out some of these for efficiency, since 'and' and 'â‡’' and to an 
// extent â‡” are all 'built-in' to the notation of an LC, and thus rules 
// involving their formal properties are not as useful in this new setting.
Rules:
{ 
  :{ W or Â¬W }                                  // exclusive middle
  :{ Â¬(Â¬W) â‰¡ W }                                // double negative
  :{ W and W â‰¡ W }                              // idempotency of and
  :{ W or W â‰¡ W }                               // idempotency of or
  // :{ :(and W V) (and V W) }                  // commutativity of and
  :{ :W or V   V or W }                         // commutativity of or
  // :{ :(â‡” W V) (â‡” V W) }                      // commutativity of â‡”
  // :{ (and (and W V) U) â‰¡ (and W (and V U)) } // associativity of and
  :{ (W or V) or U â‰¡  W or (V or U)  }          // associativity of or
  :{ (Wâ‡”V)â‡”U â‰¡ Wâ‡”(Vâ‡”U) }                        // associativity of â‡”
  :{ { W (V or U) } â‰¡ (W and V) or (W and U) }  // distributivity of and/or
  :{ W or (V and U) â‰¡ { (W or V) (W or U) } }   // distributivity of or/and
  :{ :(W â‡’ V) :(V â‡’ U) (W â‡’ U) }                // transitivity of â‡’
  :{ :(W â‡” V) :(V â‡” U) (W â‡” U) }                // transitivity of â‡”
  :{ W â‡’ V â‰¡ Â¬W or V }                          // alternate def of â‡’
  :{ :W or V :Â¬W   V }                          // alternate or-  
  :{ :W or V :Â¬V   W }                          // alternate or-
  :{ Â¬(W â‡’ V) â‰¡ { W Â¬V } }                      // negated implication
  :{ W â‡’ V â‰¡ Â¬V â‡’ Â¬W }                          // contrapositive
  :{ Â¬(W and V) â‰¡ Â¬W or Â¬V }                    // DeMorgan
  :{ Â¬(W or V)  â‰¡ { Â¬W Â¬V } }                   // DeMorgan
  :{ :â†’â† W }                                    // contradiction-
}
////////////////////////////////////////////////////////////////////////////
// Peano Axioms Lurch Lib
//

// TODO: the next line is a theorem, provable from N4, and would be a speedup
// allowing us to skip the need for a âˆ€ statement, but currently it won't
// instantiate without a BIH.
//
// :{ :ğœ†P(0) :{ :Let k be such that ğœ†P(k)   ğœ†P(ğœ(k)) } ğœ†P(n) }   // alt N4

// Declare constants
Declare 0 ğœ + â‹… â‰¤

////////////////////////////////
// Peano Axioms
////////////////////////////////
Axioms: 
{
  :{ :ğœ(m)=ğœ(n) m=n }                                             // N2
  :{ 0 â‰  ğœ(n) }                                                    // N3
  :{ :ğœ†P(0) :{ :Let k be such that ğœ†P(k)   ğœ†P(ğœ(k)) } âˆ€n.ğœ†P(n) }  // N4
  :{ n+0=n }                                                      // A0
  :{ m+ğœ(n)=ğœ(m+n) }                                              // A1
  :{ nâ‹…0=0 }                                                      // M0
  :{ mâ‹…ğœ(n)=m+mâ‹…n }                                               // M1       
  :{ mâ‰¤n â‰¡ âˆƒk.m+k=n  }                                            // I
} 
////////////////////////////////////////////////////////////////////////////
// Number Theory Lurch Lib
//

////////////////////////////////
// Number Theory Definitions
////////////////////////////////
Definitions:  
{
  Declare 1 2 3 4 5 | prime even is 
  :{ 1=ğœ(0) }
  :{ 2=ğœ(1) }
  :{ 3=ğœ(2) }
  :{ 4=ğœ(3) }
  :{ 5=ğœ(4) }  
  
  // divides
  :{ m|n â‰¡ âˆƒk.n=mâ‹…k }
  // prime
  :{ n is prime â‰¡ { 1<n Â¬(âˆƒk.1<k and k<n and k|n) } }
	// even
	:{ :n is even   n=2â‹…m for some m }
	:{ :n=2â‹…m       n is even }
} 
////////////////////////////////////////////////////////////////////////////
// Equations Rule
//
// We just include the Equations rule here so that we can compare, e.g.
// Peano proofs using BIHs to ones using the Equations rule.

Rules:
{
  // and at this point we want the helpful Equations Rule
  :{ Equations_Rule }
} 
////////////////////////////////////////////////////////////////////////////
// Peano Axioms - basic theorems
//
// This library has no dependencies, so it can be loaded ad-hoc into other 
// libraries or documents as needed.  But one would assume that such a 
// document will already have loaded basic logic and the Peano Axioms, and 
// probably the Equations lib.

Rules: 
{
  :{ ğœ(n)=n+1 }           // alt def ğœ

  :{ m+n=n+m }            // comm + 
  :{ (m+n)+p=m+(n+p) }    // assoc + 
	
  :{ nâ‹…1=n 1â‹…n=n }        // ident â‹… 
  :{ mâ‹…n=nâ‹…m }            // comm â‹…
  :{ (mâ‹…n)â‹…p=mâ‹…(nâ‹…p) }    // assoc â‹…

	:{ mâ‹…(n+p)=mâ‹…n+mâ‹…p (n+p)â‹…m=nâ‹…m+pâ‹…m }  // distributive

} 
////////////////////////////////////////////////////////////////////////////
// Recursion Lurch Lib
//

//////////////////////////////////
// Recursive Sequence Definitions
//////////////////////////////////
Declare âˆ‘ F multinom

Definitions:  
{
		// summation
    :{ âˆ‘(0,k.ğœ†P(k)) = ğœ†P(0) }
    :{ âˆ‘(ğœ(n),k.ğœ†P(k)) = ğœ†P(ğœ(n)) + âˆ‘(n,k.ğœ†P(k)) }

		// natural number exponents
		:{ z^0=1 }
		:{ z^ğœ(n)=zâ‹…z^n }

    // factorial (TODO: make the peggy parser work for factorials)

		// Fibonacci
    :{ F(0)=1 F(1)=1 }
		:{ F(n+2)=F(n+1)+F(n) }

		// multinomial coefficient
		:{ multinom(m,0)=1 multinom(0,n)=1 }
		:{ multinom(m+1,n+1)=multinom(m+1,n)+multinom(m,n+1) }
		// choose
		:{ choose(n+m,m)=multi(n,m)}		
} 
////////////////////////////////////////////////////////////////////////////
// Real Numbers Lurch Lib
//

//////////////////////////////////
// Axioms for the Reals
//////////////////////////////////
Declare â»
Axioms:  
{
		// Axioms of addition
		:{ x+0=x  0+x=x }                         // identity + 
		:{ x+(-x)=0   -x+x=0 }                    // inverse + 
		:{ x+y=y+x }                              // commutativity +
		:{ (x+y)+z=x+(y+z) }                      //associativity of +
		// Axioms of Multiplication
		:{ 1â‰ 0 1â‹…x=x xâ‹…1=x }                      // identity â‹… 
		:{ :xâ‰ 0  (xâ»)â‹…x = 1  xâ‹…(xâ»)= 1 }          // inverse â‹… 
		:{ xâ‹…y=yâ‹…x }                              // commutativity of â‹…
		:{ (xâ‹…y)â‹…z = xâ‹…(yâ‹…z) }                    // associativity of â‹…
		// Axioms of Order
		:{ Â¬(x<x) }                               // irreflexive
		:{ :x<y  :y<z   x<z }                     // transitive 
		:{  x=y or (x<y or y<x) }                 // trichotomy 
		// "Every bounded above sequence of real numbers has a least upper bound"   // complete
		// Axioms Relating +, â‹…, and <
		:{ xâ‹…(y+z) = xâ‹…y + xâ‹…z   (y+z)â‹…x = yâ‹…x + zâ‹…x }  // distributivity +,â‹…
		:{ :x<y  x+z<y+z }                              // translation +,<
		:{ :0<x  :0<y   0<xâ‹…y }                         // product of positives â‹…,<		
} 
////////////////////////////////////////////////////////////////////////////
// Elementary Naive Set Theory Lurch Lib
//

//////////////////////////////////
// Definitions for Sets
//////////////////////////////////
Declare Set âˆˆ âŠ† âˆ© âˆª âˆ– Â° ğ’«
Axioms:  
{
	:{ x âˆ‰ Set() }                                // empty set
	:{ x âˆˆ Set(a) â‰¡ x=a }                         // Finite Set Notation
	:{ x âˆˆ Set(a,b) â‰¡ x=a or x=b }                // Finite Set Notation
	:{ x âˆˆ Set(a,b,c) â‰¡ (x=a or x=b) or x=c }     // Finite Set Notation
	:{ x âˆˆ Set( z.ğœ†P(z) ) â‰¡ ğœ†P(x)  }              // Set builder notation 
	:{ :{:Let x be such that xâˆˆA  xâˆˆB } AâŠ†B }     // Subset+
	:{ :AâŠ†B :xâˆˆA  xâˆˆB }                           // Subset-
	:{ :{:Let a be such that aâˆˆA  aâˆˆB}
		 :{:Let b be such that bâˆˆB  bâˆˆA} 
		 A=B
	}                                            // Set equality                         
	:{ A âˆˆ ğ’«(B) â‰¡ AâŠ†B }                          // Power set
	:{ x âˆˆ Aâˆ©B â‰¡ { xâˆˆA xâˆˆB } }                   // Intersection
	:{ x âˆˆ AâˆªB â‰¡  xâˆˆA or xâˆˆB }                   // Union
	:{ x âˆˆ Aâˆ–B â‰¡ { xâˆˆA  xâˆ‰B } }                  // Relative Complement 
	:{ x âˆˆ AÂ° â‰¡ xâˆ‰A }                            // Complement
	
	:{ âŸ¨x,yâŸ© = âŸ¨u,vâŸ© â‰¡ { x=u y=v } }                      // Ordered Pairs
	:{ âŸ¨x,y,zâŸ© = âŸ¨u,v,wâŸ© â‰¡ { x=u y=v z=w } }              // Ordered Triple
		
	:{ zâˆˆAÃ—B â‰¡ { aâˆˆA bâˆˆB z=âŸ¨a,bâŸ© for some a,b} }          // Cartesian Product
	:{ zâˆˆAÃ—BÃ—C â‰¡ { aâˆˆA bâˆˆB câˆˆC z=âŸ¨a,b,câŸ© for some a,b } } // Cartesian Product

	// :{ x âˆˆ T iâˆˆI Ai â‰¡ âˆ€i.iâˆˆIâ‡’xâˆˆAi }               // Indexed Intersection
	// :{ x âˆˆ S iâˆˆI Ai â‡” âˆƒi, i âˆˆ I and x âˆˆ Ai }       // Indexed Union
	// Two convenient abbreviations
	// (âˆ€x âˆˆ A, P (x))â‡” âˆ€x, x âˆˆ A â‡’ P(x)
	// (âˆƒx âˆˆ A, P (x))â‡” âˆƒx, x âˆˆ A and P(x)

} 
////////////////////////////////////////////////////////////////////////////
// Elementary Functions Lurch Lib
//

//////////////////////////////////
// Definitions for Functions
//////////////////////////////////
Declare maps is â„• â„¤ â„š â„ â„‚ inv âˆ˜ 
Declare Domain Codomain Range injective surjective bijective
Definitions:  
{
	:{ :f:Aâ†’B :xâˆˆA  f(x)âˆˆB }                     // function
	:{ :f:Aâ†’B Domain(f)=A Codomain(f)=B }        // domain & codomain
  :{ :f = (x â†¦ ğœ†P(x))  f(z) = ğœ†P(z) }            // lambda expression
  :{ :f:Aâ†’B :g:Aâ†’B 
	   :{ Let x such that xâˆˆA  f(x)=g(x) }
     f=g
	}                                            // function equality
  :{ :xâˆˆS f(x)âˆˆf(S) }                          // image
  :{ :yâˆˆf(S)  xâˆˆS and y=f(x) for some x }      // image
  :{ id(A):Aâ†’A  { :xâˆˆA id(A)(x)=x } }          // identity map
  :{ :f:Aâ†’B :g:Bâ†’C gâˆ˜f:Aâ†’C }                   // composition
  :{ :f:Aâ†’B :g:Bâ†’C (gâˆ˜f)(x)=g(f(x)) }          // composition
  :{ :f is injective  :f(x)=f(y) x=y }         // injective
  :{ :f:Aâ†’B
		 :{ Let x,y be such that f(x)=f(y)
			  x=y 
		 }
     f is injective }                          // injective
  :{ :f:Aâ†’B :f is surjective :bâˆˆB  
		  aâˆˆA and b=f(a) for some a
	}                                            // surjective
	:{ :f:Aâ†’B 
		 :{ Let b such that bâˆˆB
			  âˆƒa.b=f(a)
		 }  
		 f is surjective }                         // surjective
  :{ f is bijective â‰¡ 
		 f is injective  f is surjective }         // bijective
	:{ :f:Aâ†’B  :g:Bâ†’A 
		 :gâˆ˜f=id(A) :fâˆ˜g=id(B)
	   fâ»=g }                                    // inverse function
	// :{ :f:Aâ†’B  :f is bijective 
	//     fâ»:Bâ†’A  fâ»(f(x))=x  f(fâ»(y))=y }         // inverse function

	:{ :aâˆˆf^inv(S) â‰¡ f(a)âˆˆS }		                 // inverse image
} 