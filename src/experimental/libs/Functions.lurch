include libs/Sets
////////////////////////////////////////////////////////////////////////////
// Elementary Functions Lurch Lib
//

//////////////////////////////////
// Definitions for Functions
//////////////////////////////////
Declare maps is â„• â„¤ â„š â„ â„‚ inv âˆ˜ 
Declare Domain Codomain Range injective surjective bijective
Definitions:  
{
	:{ :f:Aâ†’B :xâˆˆA  f(x)âˆˆB }                     // function
	:{ :f:Aâ†’B Domain(f)=A Codomain(f)=B }        // domain & codomain
  :{ :f = x.ğœ†P(x) f(z) = ğœ†P(z) }               // lambda expression
  :{ :f:Aâ†’B :g:Aâ†’B 
	   :{ Let x such that xâˆˆA  f(x)=g(x) }
     f=g
	}                                            // function equality
  :{ :xâˆˆS f(x)âˆˆf(S) }                          // image
  :{ :yâˆˆf(S)  xâˆˆS and y=f(x) for some x }      // image
  :{ id(A):Aâ†’A  { :xâˆˆA id(A)(x)=x } }          // identity map
  :{ :f:Aâ†’B :g:Bâ†’C gâˆ˜f:Aâ†’C }                   // composition
  :{ :f:Aâ†’B :g:Bâ†’C (gâˆ˜f)(x)=g(f(x)) }          // composition
  :{ :f is injective  :f(x)=f(y) x=y }         // injective
  :{ :f:Aâ†’B
		 :{ Let x,y be such that f(x)=f(y)
			  x=y 
		 }
     f is injective }                          // injective
  :{ :f:Aâ†’B :f is surjective :bâˆˆB  
		  aâˆˆA and b=f(a) for some a
	}                                            // surjective
	:{ :f:Aâ†’B 
		 :{ Let b such that bâˆˆB
			  aâˆˆA and b=f(a) for some a
		 }  
		 f is surjective }                         // surjective
  :{ f is bijective â‰¡ 
		 f is injective  f is surjective }         // bijective
	:{ :f:Aâ†’B  :g:Bâ†’A 
		 :gâˆ˜f=id(A) :fâˆ˜g=id(B)
	   fâ»=g }                                    // inverse function
	// :{ :f:Aâ†’B  :f is bijective 
	//     fâ»:Bâ†’A  fâ»(f(x))=x  f(fâ»(y))=y }         // inverse function

	:{ :aâˆˆf^inv(S) â‰¡ f(a)âˆˆS }		                 // inverse image
} 