include libs/PropThm
////////////////////////////////
// ND Predicate Logic Theorems
////////////////////////////////

// Notes:
//
// * symmetry and transitivity of equality is inefficient and mainly
//   useful for the alternate substitutions rule, and they aren't needed because 
//   you basically get both for free between the substitution and alternate 
//   substitution rules
// * commutative of âˆ€ and âˆƒ rules are probably more efficiently handled with
//   something like (âˆ€ x y, (@ P x y)) vs (âˆ€ y x, (@ P x y)) but it's not clear
//   the best way to do that in practice yet
// * update: we now have the Equations_Rule.  This may supercede
//   substitution and reflexive of equality. 
//   TODO: make more test examples to check this.

Rules: 
{ 
  // :{ :(= x y) (= y x) }               // symmetry of equality
  // :{ :(= x y) :(= y z) (= x z) }      // transitivity of equality
  :{ :x=y :ğœ†P(y) ğœ†P(x) }                 // alternate substutition
  // :( :(âˆ€x. (âˆ€y. (@ P x y))) (âˆ€y. (âˆ€x. (@ P x y))) }    // commutativity
  // :( :(âˆƒx. (âˆƒy. (@ P x y))) (âˆƒy. (âˆƒx. (@ P x y))) }    // commutativity
  :{ { (âˆ€x.ğœ†P(x)) (âˆ€y.ğœ†Q(y)) } â‰¡ (âˆ€x.ğœ†P(x) and ğœ†Q(x)) }   // distributivity
  :{ { (âˆƒx.ğœ†P(x)) (âˆƒy.ğœ†Q(y)) } â‰¡ (âˆƒx.ğœ†P(x) or ğœ†Q(x)) }    // distributivity
  :{ (âˆƒ!x.ğœ†W(x)) â‰¡ (âˆƒc.âˆ€z.ğœ†W(z) â‡” z=c) }  // alternate def of âˆƒ!
} 