{
    "docs": [
        {
            "location": "/", 
            "text": "The Lurch Deductive Engine (LDE)\n\n\nDocumentation forthcoming.", 
            "title": "Home"
        }, 
        {
            "location": "/#the-lurch-deductive-engine-lde", 
            "text": "Documentation forthcoming.", 
            "title": "The Lurch Deductive Engine (LDE)"
        }, 
        {
            "location": "/overview/", 
            "text": "LDE Design Overview\n\n\nThis page lists the design decisions made by the Lurch team to date\nregarding the LDE, with reasons and explanations for each.  This document\ncan be used as reference, and to guide development, but it may also be\nchanged as better ideas come along.\n\n\nElegance and Simplicity\n\n\nThese are of utmost importance, because\n\n\n\n\nthey make Lurch easier to explain to students or in an Advanced User's\n   Guide (AUG),\n\n\nthey make Lurch easier to test because it has fewer unusual corner cases\n   or special handling of odd circumstances,\n\n\nthey make Lurch easier to implement for the same reason, and\n\n\nthey make it easier for us to be confident that our designs are good,\n   because they're easier to hold in your head and grok all at once.\n\n\n\n\nFeedback and Validation\n\n\n\n\nThe primary purpose of the Lurch application is to give feedback to the\n   user about the work they type into their document.\n\n\nBecause this will often involve validating steps of work in a proof, we\n   may use the terms \"feedback\" and \"validation\" interchangeably, even\n   though technically validation is just a particular type of feedback\n   (though the most common type in our case).\n\n\nOne-Pass Validation (OPV)\n is a paradigm in which, whenever the app\n   needs to update feedback in response to changes made by the user, it\n   does so by reprocessing every bit of meaningful content from scratch, in\n   one (large, possibly time-consuming) pass over the whole document.\n\n\nReal-Time Validation (RTV)\n is a paradigm in which, whenever the app\n   needs to update feedback in response to changes made by the user, it\n   attempts to re-use as much information from previous validation as\n   possible, only updating those portions of it that need updating in\n   response to the specific change the user just made.  Thus RTV is\n   trickier to design and implement than OPV, but more efficient at\n   run-time.\n\n\nAn important concept for our test suite is that any RTV design can be\n   converted to an OPV design trivially, and then used for comparison\n   testing.  Simply replace all sophisticated RTV-style change event\n   handlers with OPV-style ones, that mark the entire document as needing\n   reprocessing.  Then any potential change that can be made to the user's\n   document can be run through each of these engines in parallel, and the\n   results compared for equivalence.\n\n\nNote that the choice of OPV vs. RTV is independent of the choice of\n   manual validation vs. automatic validation.  RTV certainly makes\n   automatic validation nicer, and thus makes manual validation less\n   appealing, but you could choose anything from among\n   \n\\{\\text{OPV},\\text{RTV}\\}\\times\\{\\text{auto},\\text{manual}\\}\n.\n\n\n\n\nLDE and UI\n\n\n\n\nWe have a paradigm in which the UI is exactly that (user interface) and\n   the LDE (Lurch Deductive Engine) is the brain that operates in one or\n   more background threads, processing what the user has given the app\n   through the UI.\n\n\nWe aim to implement every feature in the LDE if possible, but implement\n   in the UI only those features that can't be implemented in the LDE.\n   Here, \"if possible\" means that it would not break the model-view\n   paradigm to implement it in the LDE (i.e., the LDE wouldn't need to\n   speak HTML).  Reasons for this:\n\n\nThe LDE will be implemented in pure JS, no DOM, so that it can be\n  used in a WebWorker and in the unit testing suite.\n\n\nTherefore the bigger the LDE is, the more of our code has been\n  subject to rigorous unit tests.\n\n\nAnd the bigger the LDE is, the more of our code is run out of the UX\n  thread, and thus the more responsive our app is.\n\n\n\n\n\n\nThe decisions recorded here are almost entirely about the design of the\n   LDE, not the UI.\n\n\n\n\nStructures\n\n\n\n\nDefine a \nstructure\n to be the basic unit of meaning in the LDE.\n\n\nThis includes document-level structures such as a section,\n  subsection, proof, subproof, etc., which are analogous to block-level\n  items like DIV or P in HTML, and \n\\begin{X}...\\end{X}\n in LaTeX.\n\n\nBut it also includes inline structures (SPANs in HTML, \n\\foo{...}\n or\n  \n$...$\n in LaTeX).\n\n\nStructures can be nested acyclically.\n\n\n\n\n\n\nExamples of types of structures that we may choose to define later:\n\n\nProofs/Subproofs, with one specific flavor of it being the kind that\n  declares a variable first\n\n\nDefinitions of rules, axioms, language rules\n\n\nFormal systems (or \"mathematical topics\")\n\n\nTheorems and pairing of them with proofs\n\n\nExpressions\n\n\nMaybe variables will be declared by based on placing a variable\n  inside an expression by itself, at the head of a variable declaration\n  subproof, or maybe by creating a new structure type for variable\n  declarations, or maybe something else\n\n\nHomework problems\n\n\nExamples (an environment in which anything you declare ends its scope\n  at the end of the example, no matter what it was)\n\n\n\n\n\n\nThe set of structure types should equal the set of common mathematical\n   structures that mathematics students should be learning anyway, and they\n   should behave the same in Lurch as in mathematics.  This ensures that\n   Lurch doesn't add to the mathematics learning curve in this sense.\n\n\nNot every structure is permitted to contain every other type of\n   structure.  But such rules are enforced through validation, which we\n   will not be defining for some time yet, so this comment is just a\n   preview of what's to come.  For instance, expressions can contain only\n   other expressions.\n\n\nAt some later point, we may care about the meanings of structures, so\n   that they can be used as premises in proofs.  At such a time, we will\n   ensure that a structure's meaning includes the unjustified steps in the\n   structure (which function as premises), the final step in the structure\n   (which functions as its conclusion), any variables declared within it\n   (which are bound in it), and so on, but it is not necessary to define\n   those details yet.  I mention them here merely so that the idea is not\n   lost.\n\n\n\n\nAccessibility\n\n\n\n\nA structure A is accessible to a structure B if some ancestor structure\n   of B (possibly B itself) is a sibling of A, but A is the (strictly)\n   earlier of the two siblings within their parent structure.\n\n\nEquivalently, we can speak of \"scope\" rather than accessibility.  The\n   scope of a structure A is all later siblings of A in the same parent,\n   along with all their descendants.  Thus B is in the scope of A iff A is\n   accessible to B.\n\n\n\n\nAttributes\n\n\n\n\nEvery structure contains a key-value dictionary called \nexternal\n   attributes,\n which are read-only from the point of view of the LDE, and\n   are read-write from the point of view of the UI.  They are called\n   \"external\" because, from the LDE's point of view, they come from\n   elsewhere (the UI).\n\n\nEvery structure contains a key-value dictionary called \ncomputed\n   attributes,\n which are read-only from the point of view of the UI, and\n   are read-write from the point of view of the LDE.  They are called\n   \"computed\" because the LDE's job is to compute stuff, which it stores in\n   these attributes.\n\n\nThese two dictionaries are disjoint.  It is possible for a single key k\n   to have one value in the one dictionary, and another value in the other\n   dictionary.\n\n\n\n\nDocument\n\n\n\n\nThe entire document will be represented to the LDE as a single\n   structure, usually with a nonzero number of inner structures.\n\n\nWe call the representation of the entire document as a structure the LDE\n   Document, a phrase chosen to connote \"the LDE's view of the document,\n   not the one the user sees in the UI.\"\n\n\nOne main job of the UI is to convert from what the user sees into the\n   LDE Document.\n\n\nSo to the list of structure types above, add \"Document.\"\n\n\nThe entire LDE Document data structure will live inside the LDE module.\n   In the main Lurch app, this implies that the LDE Document will be stored\n   in the background thread where the LDE runs, not in the UI.  Thus the UI\n   will communicate across threads to create the LDE Document.  Details on\n   this later.\n\n\n\n\nSome brief UI comments\n\n\n\n\nMost of the purpose of the UI will be to convert the HTML document the\n   user sees into the LDE Document the LDE processes, then to show the user\n   in the HTML document and feedback the LDE sends back.\n\n\nIn service to that purpose, the UI contains many (largely independent\n  and usually small) features for encoding the HTML document into the\n  LDE Document.\n\n\nExamples include conventions for processing groups, connections,\n  numbered lists, section headings, finding meaning in text through\n  regular expressions, and the meanings of various LaTeX-like\n  \n\\shortcuts\n.\n\n\nA document author chooses which subset of these features to enable by\n  making choices in the document settings dialog.  Those settings are\n  stored in document metadata, and propagate to dependencies (defined\n  below).\n\n\nThe UI will have very little hard-coded (i.e., non-customizable)\n  procedures for interpreting the HTML document into the LDE document;\n  the settings above are highly choosable by the user.\n\n\nThe only constrained interpretation conventions (i.e., few or no\n  options for changing the interpretation) would be those that have\n  mathematical names, such as \"proof,\" which have a specific meaning\n  that it would be educationally counterproductive to interpret another\n  way.\n\n\nIn addition, we may choose a specific set of document settings to use\n  throughout the standard libraries that ship with Lurch, to show best\n  practices and help users with consistency and predictability.\n\n\n\n\n\n\nOther UI details:\n\n\nBecause we have a UI that allows users to make connections among\n  groups, the structures in the hierarchy may include, among their\n  external attributes, a binary, edge-labeled multigraph.  (Note that\n  this does not require that every connection in the HTML document\n  become two Structures in the LDE Document with attributes connecting\n  them.  Nor does it stipulate that some concept--such as\n  labeling--that we might decide to represent as part of this\n  multigraph can't also be represented sometimes in another way as\n  well.)\n\n\nIf we require the LDE to send a signal when validation completes,\n  then we can make a UI setting of whether to show feedback as the\n  feedback arrives, or only after the \"all validation complete\" signal\n  arrives (and thus feedback has stabilized).\n\n\n\n\n\n\n\n\nStructures are OOP Objects\n\n\n\n\nA structure exposes a set of data and methods about its internal state\n   to the rest of the app, in much the same way as Objects in OOP do, with\n   the type of structure (from the list above, e.g., Theorem or Example)\n   functioning as the \"class\" of the Object.\n\n\nSome methods in a structure will be time-intensive to run, and thus\n   should use an asynchronous paradigm, queueing the tasks for running when\n   the LDE thread has time.  The most time-intensive tasks, such as\n   matching and parsing, may be delegated to yet other background threads\n   by the LDE thread.\n\n\n\n\nExporting data from structures\n\n\n\n\nHere is an important example method that all structures should have\n   (though each class may implement it differently):\n\n\nA method that reports which structures (usually child structures of\n  A), if any, are to be made accessible to any structure B in the scope\n  of A (thus changing the normal scoping rules).\n\n\nThe flexibility inherent in the vagueness of this exporting notion is\n  useful.  For instance, a single theorem in the document might be\n  encoded in the LDE document as having many children, some of which\n  are its various interpretations as a rule of inference, and export\n  them all, so that any can be used/cited later.\n\n\nNote that the exports method need not copy child structures directly\n  for exporting.  It may combine/manipulate/compute structures to\n  export based on its children in any way.  Thus \"scope\" is a simple\n  and clean definition, which this function sort of indirectly extends.\n\n\n\n\n\n\nWe will define much of the functionality of the LDE as the various\n   structures in the document calling methods in one another, which is\n   simple and elegant.  But it requires that we carefully track and cache\n   the clean/dirty status of each structure, to retain efficiency.\n\n\n\n\nDependencies as a special case\n\n\n\n\nThe current paradigm (already implemented) in webLurch is that a\n   dependency must specify what data it exports to any document that\n   depends on it.\n\n\nSuch data will be stored in the dependency document's metadata, so that\n   documents depending on it can easily import it.  It will include\n   anything that the dependency imported from its dependencies, and so on\n   to arbitrary depth.\n\n\nBecause we now require every structure to know what it exports to later\n   structures, the question of what a document exports is simply a special\n   case of that.  The document is itself a structure, and thus it can\n   already answer the \"what does this document export?\" question.\n\n\nRecall from above that one of the pieces of data that a document will\n   export is its document settings, as described earlier.\n\n\n\n\nDesign Phases\n\n\n\n\nThe question, \"Which structure should be designed first?\" is tricky\n   because each structure is rather complex, and they're rather\n   interdependent.\n\n\nOne approach would be to design each structure incrementally, adding\n   features in phases.\n\n\nThus we might begin with an LDE implementation that has just a few\n   features for a few structure types, and yet is sufficient for building\n   very simply Lurch libraries.\n\n\nThis lets us build familiarity and knowledge as we do the design, so\n   we're better at it by the time we get to the hard stuff.\n\n\nPhases 2, 3, and so on can add features and structure types, thus\n   enabling more and more sophisticated Lurch libraries, until we have\n   reached the level of power that supports a first proof course.\n\n\n\n\nSee other documentation on this site for the contents of each design phase.", 
            "title": "Overview"
        }, 
        {
            "location": "/overview/#lde-design-overview", 
            "text": "This page lists the design decisions made by the Lurch team to date\nregarding the LDE, with reasons and explanations for each.  This document\ncan be used as reference, and to guide development, but it may also be\nchanged as better ideas come along.", 
            "title": "LDE Design Overview"
        }, 
        {
            "location": "/overview/#elegance-and-simplicity", 
            "text": "These are of utmost importance, because   they make Lurch easier to explain to students or in an Advanced User's\n   Guide (AUG),  they make Lurch easier to test because it has fewer unusual corner cases\n   or special handling of odd circumstances,  they make Lurch easier to implement for the same reason, and  they make it easier for us to be confident that our designs are good,\n   because they're easier to hold in your head and grok all at once.", 
            "title": "Elegance and Simplicity"
        }, 
        {
            "location": "/overview/#feedback-and-validation", 
            "text": "The primary purpose of the Lurch application is to give feedback to the\n   user about the work they type into their document.  Because this will often involve validating steps of work in a proof, we\n   may use the terms \"feedback\" and \"validation\" interchangeably, even\n   though technically validation is just a particular type of feedback\n   (though the most common type in our case).  One-Pass Validation (OPV)  is a paradigm in which, whenever the app\n   needs to update feedback in response to changes made by the user, it\n   does so by reprocessing every bit of meaningful content from scratch, in\n   one (large, possibly time-consuming) pass over the whole document.  Real-Time Validation (RTV)  is a paradigm in which, whenever the app\n   needs to update feedback in response to changes made by the user, it\n   attempts to re-use as much information from previous validation as\n   possible, only updating those portions of it that need updating in\n   response to the specific change the user just made.  Thus RTV is\n   trickier to design and implement than OPV, but more efficient at\n   run-time.  An important concept for our test suite is that any RTV design can be\n   converted to an OPV design trivially, and then used for comparison\n   testing.  Simply replace all sophisticated RTV-style change event\n   handlers with OPV-style ones, that mark the entire document as needing\n   reprocessing.  Then any potential change that can be made to the user's\n   document can be run through each of these engines in parallel, and the\n   results compared for equivalence.  Note that the choice of OPV vs. RTV is independent of the choice of\n   manual validation vs. automatic validation.  RTV certainly makes\n   automatic validation nicer, and thus makes manual validation less\n   appealing, but you could choose anything from among\n    \\{\\text{OPV},\\text{RTV}\\}\\times\\{\\text{auto},\\text{manual}\\} .", 
            "title": "Feedback and Validation"
        }, 
        {
            "location": "/overview/#lde-and-ui", 
            "text": "We have a paradigm in which the UI is exactly that (user interface) and\n   the LDE (Lurch Deductive Engine) is the brain that operates in one or\n   more background threads, processing what the user has given the app\n   through the UI.  We aim to implement every feature in the LDE if possible, but implement\n   in the UI only those features that can't be implemented in the LDE.\n   Here, \"if possible\" means that it would not break the model-view\n   paradigm to implement it in the LDE (i.e., the LDE wouldn't need to\n   speak HTML).  Reasons for this:  The LDE will be implemented in pure JS, no DOM, so that it can be\n  used in a WebWorker and in the unit testing suite.  Therefore the bigger the LDE is, the more of our code has been\n  subject to rigorous unit tests.  And the bigger the LDE is, the more of our code is run out of the UX\n  thread, and thus the more responsive our app is.    The decisions recorded here are almost entirely about the design of the\n   LDE, not the UI.", 
            "title": "LDE and UI"
        }, 
        {
            "location": "/overview/#structures", 
            "text": "Define a  structure  to be the basic unit of meaning in the LDE.  This includes document-level structures such as a section,\n  subsection, proof, subproof, etc., which are analogous to block-level\n  items like DIV or P in HTML, and  \\begin{X}...\\end{X}  in LaTeX.  But it also includes inline structures (SPANs in HTML,  \\foo{...}  or\n   $...$  in LaTeX).  Structures can be nested acyclically.    Examples of types of structures that we may choose to define later:  Proofs/Subproofs, with one specific flavor of it being the kind that\n  declares a variable first  Definitions of rules, axioms, language rules  Formal systems (or \"mathematical topics\")  Theorems and pairing of them with proofs  Expressions  Maybe variables will be declared by based on placing a variable\n  inside an expression by itself, at the head of a variable declaration\n  subproof, or maybe by creating a new structure type for variable\n  declarations, or maybe something else  Homework problems  Examples (an environment in which anything you declare ends its scope\n  at the end of the example, no matter what it was)    The set of structure types should equal the set of common mathematical\n   structures that mathematics students should be learning anyway, and they\n   should behave the same in Lurch as in mathematics.  This ensures that\n   Lurch doesn't add to the mathematics learning curve in this sense.  Not every structure is permitted to contain every other type of\n   structure.  But such rules are enforced through validation, which we\n   will not be defining for some time yet, so this comment is just a\n   preview of what's to come.  For instance, expressions can contain only\n   other expressions.  At some later point, we may care about the meanings of structures, so\n   that they can be used as premises in proofs.  At such a time, we will\n   ensure that a structure's meaning includes the unjustified steps in the\n   structure (which function as premises), the final step in the structure\n   (which functions as its conclusion), any variables declared within it\n   (which are bound in it), and so on, but it is not necessary to define\n   those details yet.  I mention them here merely so that the idea is not\n   lost.", 
            "title": "Structures"
        }, 
        {
            "location": "/overview/#accessibility", 
            "text": "A structure A is accessible to a structure B if some ancestor structure\n   of B (possibly B itself) is a sibling of A, but A is the (strictly)\n   earlier of the two siblings within their parent structure.  Equivalently, we can speak of \"scope\" rather than accessibility.  The\n   scope of a structure A is all later siblings of A in the same parent,\n   along with all their descendants.  Thus B is in the scope of A iff A is\n   accessible to B.", 
            "title": "Accessibility"
        }, 
        {
            "location": "/overview/#attributes", 
            "text": "Every structure contains a key-value dictionary called  external\n   attributes,  which are read-only from the point of view of the LDE, and\n   are read-write from the point of view of the UI.  They are called\n   \"external\" because, from the LDE's point of view, they come from\n   elsewhere (the UI).  Every structure contains a key-value dictionary called  computed\n   attributes,  which are read-only from the point of view of the UI, and\n   are read-write from the point of view of the LDE.  They are called\n   \"computed\" because the LDE's job is to compute stuff, which it stores in\n   these attributes.  These two dictionaries are disjoint.  It is possible for a single key k\n   to have one value in the one dictionary, and another value in the other\n   dictionary.", 
            "title": "Attributes"
        }, 
        {
            "location": "/overview/#document", 
            "text": "The entire document will be represented to the LDE as a single\n   structure, usually with a nonzero number of inner structures.  We call the representation of the entire document as a structure the LDE\n   Document, a phrase chosen to connote \"the LDE's view of the document,\n   not the one the user sees in the UI.\"  One main job of the UI is to convert from what the user sees into the\n   LDE Document.  So to the list of structure types above, add \"Document.\"  The entire LDE Document data structure will live inside the LDE module.\n   In the main Lurch app, this implies that the LDE Document will be stored\n   in the background thread where the LDE runs, not in the UI.  Thus the UI\n   will communicate across threads to create the LDE Document.  Details on\n   this later.", 
            "title": "Document"
        }, 
        {
            "location": "/overview/#some-brief-ui-comments", 
            "text": "Most of the purpose of the UI will be to convert the HTML document the\n   user sees into the LDE Document the LDE processes, then to show the user\n   in the HTML document and feedback the LDE sends back.  In service to that purpose, the UI contains many (largely independent\n  and usually small) features for encoding the HTML document into the\n  LDE Document.  Examples include conventions for processing groups, connections,\n  numbered lists, section headings, finding meaning in text through\n  regular expressions, and the meanings of various LaTeX-like\n   \\shortcuts .  A document author chooses which subset of these features to enable by\n  making choices in the document settings dialog.  Those settings are\n  stored in document metadata, and propagate to dependencies (defined\n  below).  The UI will have very little hard-coded (i.e., non-customizable)\n  procedures for interpreting the HTML document into the LDE document;\n  the settings above are highly choosable by the user.  The only constrained interpretation conventions (i.e., few or no\n  options for changing the interpretation) would be those that have\n  mathematical names, such as \"proof,\" which have a specific meaning\n  that it would be educationally counterproductive to interpret another\n  way.  In addition, we may choose a specific set of document settings to use\n  throughout the standard libraries that ship with Lurch, to show best\n  practices and help users with consistency and predictability.    Other UI details:  Because we have a UI that allows users to make connections among\n  groups, the structures in the hierarchy may include, among their\n  external attributes, a binary, edge-labeled multigraph.  (Note that\n  this does not require that every connection in the HTML document\n  become two Structures in the LDE Document with attributes connecting\n  them.  Nor does it stipulate that some concept--such as\n  labeling--that we might decide to represent as part of this\n  multigraph can't also be represented sometimes in another way as\n  well.)  If we require the LDE to send a signal when validation completes,\n  then we can make a UI setting of whether to show feedback as the\n  feedback arrives, or only after the \"all validation complete\" signal\n  arrives (and thus feedback has stabilized).", 
            "title": "Some brief UI comments"
        }, 
        {
            "location": "/overview/#structures-are-oop-objects", 
            "text": "A structure exposes a set of data and methods about its internal state\n   to the rest of the app, in much the same way as Objects in OOP do, with\n   the type of structure (from the list above, e.g., Theorem or Example)\n   functioning as the \"class\" of the Object.  Some methods in a structure will be time-intensive to run, and thus\n   should use an asynchronous paradigm, queueing the tasks for running when\n   the LDE thread has time.  The most time-intensive tasks, such as\n   matching and parsing, may be delegated to yet other background threads\n   by the LDE thread.", 
            "title": "Structures are OOP Objects"
        }, 
        {
            "location": "/overview/#exporting-data-from-structures", 
            "text": "Here is an important example method that all structures should have\n   (though each class may implement it differently):  A method that reports which structures (usually child structures of\n  A), if any, are to be made accessible to any structure B in the scope\n  of A (thus changing the normal scoping rules).  The flexibility inherent in the vagueness of this exporting notion is\n  useful.  For instance, a single theorem in the document might be\n  encoded in the LDE document as having many children, some of which\n  are its various interpretations as a rule of inference, and export\n  them all, so that any can be used/cited later.  Note that the exports method need not copy child structures directly\n  for exporting.  It may combine/manipulate/compute structures to\n  export based on its children in any way.  Thus \"scope\" is a simple\n  and clean definition, which this function sort of indirectly extends.    We will define much of the functionality of the LDE as the various\n   structures in the document calling methods in one another, which is\n   simple and elegant.  But it requires that we carefully track and cache\n   the clean/dirty status of each structure, to retain efficiency.", 
            "title": "Exporting data from structures"
        }, 
        {
            "location": "/overview/#dependencies-as-a-special-case", 
            "text": "The current paradigm (already implemented) in webLurch is that a\n   dependency must specify what data it exports to any document that\n   depends on it.  Such data will be stored in the dependency document's metadata, so that\n   documents depending on it can easily import it.  It will include\n   anything that the dependency imported from its dependencies, and so on\n   to arbitrary depth.  Because we now require every structure to know what it exports to later\n   structures, the question of what a document exports is simply a special\n   case of that.  The document is itself a structure, and thus it can\n   already answer the \"what does this document export?\" question.  Recall from above that one of the pieces of data that a document will\n   export is its document settings, as described earlier.", 
            "title": "Dependencies as a special case"
        }, 
        {
            "location": "/overview/#design-phases", 
            "text": "The question, \"Which structure should be designed first?\" is tricky\n   because each structure is rather complex, and they're rather\n   interdependent.  One approach would be to design each structure incrementally, adding\n   features in phases.  Thus we might begin with an LDE implementation that has just a few\n   features for a few structure types, and yet is sufficient for building\n   very simply Lurch libraries.  This lets us build familiarity and knowledge as we do the design, so\n   we're better at it by the time we get to the hard stuff.  Phases 2, 3, and so on can add features and structure types, thus\n   enabling more and more sophisticated Lurch libraries, until we have\n   reached the level of power that supports a first proof course.   See other documentation on this site for the contents of each design phase.", 
            "title": "Design Phases"
        }, 
        {
            "location": "/phase0-structures/", 
            "text": "LDE Design Phase 0: Structures\n\n\nAll the later phases will actually implement stuff that we could use to\nmake real documents and libraries.  This one doesn't, so it's called Phase\n0.\n\n\nIn this phase, we just design the generic Structure class on which everything else will depend, and the infrastructure of the LDE itself.\n\n\nAt the end of this phase, we could write unit tests of the whole Structure class and its LDE context, thus guaranteeing that all later phases rest on a good foundation.\n\n\nMethods in the Structure class\n\n\n\n\nS.setComputedAttribute(key,value)\n caches a computed value under a\n   certain key\n\n\nOne important example of a computed attribute:\n\n\nS.setComputedAttribute(\"feedback\",obj)\n tells the UI the type of\n  feedback it should show for structure S, with obj having these keys:\n\n\nresult: a string, either \"valid\" or \"invalid\" or \"indeterminate\"\n\n\nmessage: a string, the message should be shown on hover of the\n  feedback indicator\n\n\nsection: (optional) which character (or range of characters) are\n  the specific ones on which the feedback focuses.\n\n\nFor instance, if something doesn't parse, you might want to\n  point out where it failed.\n\n\nOr if an expression parses into many steps of work, each of\n  which gets validated separately, then the feedback needs to\n  be localized.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nS.compute(key1,key2,...)\n runs whatever function is necessary to\n   compute and store the attributes for the keys.\n\n\nIt should usually be obvious what this is from context, like if S has\n  a function \nS.meaning()\n and we say \nS.compute(\"meaning\")\n that means\n  run \nS.setComputedAttribute(\"meaning\",S.meaning())\n.\n\n\nBut more complex examples are possible, and each structure type is in\n  charge of implementing \ncompute()\n in the appropriate way.\n\n\n\n\n\n\nS.clearComputedAttributes(key1,key2,...)\n removes the computed values;\n   calling it with no arguments removes all computed values\n\n\nS.getComputedAttribute(key)\n fetches the computed attribute value, or\n   returns undefined if it's not stored\n\n\nS.properties()\n looks at the set of other structures that connect to S\n   via arrows, and forms a dictionary of name=value pairs, the \"properties\"\n   of S.\n\n\nS.isAccessibleTo(S')\n returns true or false, implementing the\n   accessibility relation defined earlier.\n\n\nS.findCited(n)\n finds the first structure S' accessible to S with\n   name=n in \nS'.attributes()\n, or undefined if there is no such structure\n   S'.\n\n\nS.whatCitesMe()\n finds all structures S' in the scope of S with\n   a=\nS.attributes().name\n in \nS'.attributes()\n, with a being one of the\n   keys we use for citation, such as \"reason\" or \"premise\" and so on.\n\n\nThere may be a need later to create other accessibility-related\n   routines, such as \nS.allAccessibleToMe()\n or \nS.myScope()\n or\n   \nS.allAccessibleSatisfying(P)\n etc.\n\n\nS.wasInserted()\n is a function that the UI will call in a brand new\n   structure as soon as it is inserted into the document.  Each structure\n   type may implement this function to do whatever it feels is necessary to\n   initialize its internal data and notify any nearby nodes in the LDE\n   Document about its arrival.  Some structure types may choose to leave\n   this as an empty function.\n\n\nS.wasRemoved(parent,index)\n is a function that the UI will call in a\n   structure the moment it is deleted from the document (but not yet\n   deleted from JavaScript memory).  The first parameter will be the former\n   parent structure (which will always exist, since the root of the LDE\n   Document can't be deleted) and the index that S formerly had within that\n   parent.  Similarly, each structure type can implement this as it sees\n   fit, including doing nothing.  Note that replacing one structure with\n   another will yield a call to \nS.wasRemoved()\n in the one structure and\n   \nS.wasInserted()\n in the other.\n\n\nS.wasChanged()\n is a function that the UI will call in a structure if\n   something about the structure changed (such as one of its attributes or\n   the contents of an atomic structure)\n\n\nS.text()\n returns the contents of S as plain text\n\n\nS.children()\n yields an ordered array of structures immediately\n  inside S\n\n\nS.parent()\n yields the parent structure of S, or undefined if S is\n  the LDE Document root\n\n\n\n\n\n\n\n\nLDE in general\n\n\nWhen the LDE is loaded into memory it will:\n\n\n\n\nCreate a global Structure that is the LDE Document.  It will be a\n   generic Structure, not a subclass.  It will have no children; they\n   can be added later.  That is, it starts as a one-node tree, root only.\n\n\nEstablish a global mapping from unique Structure IDs to the instances\n   that have those IDs\n\n\nDefines a global function for deserializing Structure instances (or\n   subclass instances) from JSON data\n\n\nIf it detects that it is being run in a background thread, it will\n   set up listeners for messages from the parent thread.  These\n   listeners will handle messages of three types:\n\n\nInsert a new subtree.\n\n\nThe message must include the unique ID of the parent, the\n  index at which the subtree will be inserted, and all the data\n  defining the subtree (serialized in JSON form, as required\n  for transmission to JavaScript background threads).\n\n\nIf the Structure (once it's deserialized) doesn't have an ID,\n  give it a new, unique one as determined by the global\n  mapping, and insert the new (id,instance) pair into that\n  mapping\n\n\n\n\n\n\nDelete an existing subtree.  The message must include the unique\n  ID of the tree to delete.  Remove it from the global ID mapping\n  as well and erase its ID attribute.\n\n\nReplace a subtree with a new one.  The message must include the\n  unique ID of the tree to replace and the data defining the\n  replacement (serialized as just described).  Remove the replaced\n  one from the global ID mapping as well and erase its ID attribute.\n\n\n\n\n\n\nEven if it is not being run in a background thread (but perhaps was\n   loaded as a module in some command-line app, for instance) it will\n   still expose insert, delete, and replace functions as part of the\n   module's API.\n\n\nWe will call any kind of insertion, removal, or replacement of\n   subtrees of the LDE Document a change event, whether it happened via\n   a message from a parent thread or as a function call to the LDE as a\n   module in a larger app.\n\n\n\n\nNotation in code\n\n\nEnsure that the Structure (and, later, other subclass) constructors are\nsophisticated enough to help us build LDE Documents easily in the unit\ntesting suite, like so:\n\n\nStructure(\n    FormalSystem(\n        Rule(\n            \nfunction ( step ) { return { valid: step.text().length \n 5, message: 'Boy is this silly.' }; }\n,\n        ).attr( { name : \nsilly rule\n } )\n    ),\n    AtomicExpression( \nyay\n ).attr( { id : 1 } ),\n    AtomicExpression( \nsilly rule\n ).attr( { \noutgoing edges\n : [ { targetId : 1, type : \nreason\n } ] ),\n    AtomicExpression( \noh rats\n ).attr( { id : 2 } ),\n    AtomicExpression( \nsilly rule\n ).attr( { \noutgoing edges\n : [ { targetId : 2, type : \nreason\n } ] )\n)\n\n\n\n\nor even\n\n\nStructure(\n    FormalSystem(\n        Rule(\n            \nfunction ( step ) { return { valid: step.text().length \n 5, message: 'Boy is this silly.' }; }\n,\n        ).attr( { name : \nsilly rule\n } )\n    ),\n    AtomicExpression( \nyay\n ).attr( { id : 1 } ),\n    AtomicExpression( \nsilly rule\n ).attr( { \nreason for\n : 1 } ),\n    AtomicExpression( \noh rats\n ).attr( { id : 2 } ),\n    AtomicExpression( \nsilly rule\n ).attr( { \nreason for\n : 2 } )\n)\n\n\n\n\nor even\n\n\nStructure(\n    FormalSystem(\n        Rule(\n            \nfunction ( step ) { return { valid: step.text().length \n 5, message: 'Boy is this silly.' }; }\n,\n        ).attr( { name : \nsilly rule\n } )\n    ),\n    AtomicExpression( \nyay\n ),\n    AtomicExpression( \nsilly rule\n ).attr( { \nreason for\n : \nprevious\n } ),\n    AtomicExpression( \noh rats\n ),\n    AtomicExpression( \nsilly rule\n ).attr( { \nreason for\n : \nprevious\n } )\n)", 
            "title": "Phase 0, Structures"
        }, 
        {
            "location": "/phase0-structures/#lde-design-phase-0-structures", 
            "text": "All the later phases will actually implement stuff that we could use to\nmake real documents and libraries.  This one doesn't, so it's called Phase\n0.  In this phase, we just design the generic Structure class on which everything else will depend, and the infrastructure of the LDE itself.  At the end of this phase, we could write unit tests of the whole Structure class and its LDE context, thus guaranteeing that all later phases rest on a good foundation.", 
            "title": "LDE Design Phase 0: Structures"
        }, 
        {
            "location": "/phase0-structures/#methods-in-the-structure-class", 
            "text": "S.setComputedAttribute(key,value)  caches a computed value under a\n   certain key  One important example of a computed attribute:  S.setComputedAttribute(\"feedback\",obj)  tells the UI the type of\n  feedback it should show for structure S, with obj having these keys:  result: a string, either \"valid\" or \"invalid\" or \"indeterminate\"  message: a string, the message should be shown on hover of the\n  feedback indicator  section: (optional) which character (or range of characters) are\n  the specific ones on which the feedback focuses.  For instance, if something doesn't parse, you might want to\n  point out where it failed.  Or if an expression parses into many steps of work, each of\n  which gets validated separately, then the feedback needs to\n  be localized.        S.compute(key1,key2,...)  runs whatever function is necessary to\n   compute and store the attributes for the keys.  It should usually be obvious what this is from context, like if S has\n  a function  S.meaning()  and we say  S.compute(\"meaning\")  that means\n  run  S.setComputedAttribute(\"meaning\",S.meaning()) .  But more complex examples are possible, and each structure type is in\n  charge of implementing  compute()  in the appropriate way.    S.clearComputedAttributes(key1,key2,...)  removes the computed values;\n   calling it with no arguments removes all computed values  S.getComputedAttribute(key)  fetches the computed attribute value, or\n   returns undefined if it's not stored  S.properties()  looks at the set of other structures that connect to S\n   via arrows, and forms a dictionary of name=value pairs, the \"properties\"\n   of S.  S.isAccessibleTo(S')  returns true or false, implementing the\n   accessibility relation defined earlier.  S.findCited(n)  finds the first structure S' accessible to S with\n   name=n in  S'.attributes() , or undefined if there is no such structure\n   S'.  S.whatCitesMe()  finds all structures S' in the scope of S with\n   a= S.attributes().name  in  S'.attributes() , with a being one of the\n   keys we use for citation, such as \"reason\" or \"premise\" and so on.  There may be a need later to create other accessibility-related\n   routines, such as  S.allAccessibleToMe()  or  S.myScope()  or\n    S.allAccessibleSatisfying(P)  etc.  S.wasInserted()  is a function that the UI will call in a brand new\n   structure as soon as it is inserted into the document.  Each structure\n   type may implement this function to do whatever it feels is necessary to\n   initialize its internal data and notify any nearby nodes in the LDE\n   Document about its arrival.  Some structure types may choose to leave\n   this as an empty function.  S.wasRemoved(parent,index)  is a function that the UI will call in a\n   structure the moment it is deleted from the document (but not yet\n   deleted from JavaScript memory).  The first parameter will be the former\n   parent structure (which will always exist, since the root of the LDE\n   Document can't be deleted) and the index that S formerly had within that\n   parent.  Similarly, each structure type can implement this as it sees\n   fit, including doing nothing.  Note that replacing one structure with\n   another will yield a call to  S.wasRemoved()  in the one structure and\n    S.wasInserted()  in the other.  S.wasChanged()  is a function that the UI will call in a structure if\n   something about the structure changed (such as one of its attributes or\n   the contents of an atomic structure)  S.text()  returns the contents of S as plain text  S.children()  yields an ordered array of structures immediately\n  inside S  S.parent()  yields the parent structure of S, or undefined if S is\n  the LDE Document root", 
            "title": "Methods in the Structure class"
        }, 
        {
            "location": "/phase0-structures/#lde-in-general", 
            "text": "When the LDE is loaded into memory it will:   Create a global Structure that is the LDE Document.  It will be a\n   generic Structure, not a subclass.  It will have no children; they\n   can be added later.  That is, it starts as a one-node tree, root only.  Establish a global mapping from unique Structure IDs to the instances\n   that have those IDs  Defines a global function for deserializing Structure instances (or\n   subclass instances) from JSON data  If it detects that it is being run in a background thread, it will\n   set up listeners for messages from the parent thread.  These\n   listeners will handle messages of three types:  Insert a new subtree.  The message must include the unique ID of the parent, the\n  index at which the subtree will be inserted, and all the data\n  defining the subtree (serialized in JSON form, as required\n  for transmission to JavaScript background threads).  If the Structure (once it's deserialized) doesn't have an ID,\n  give it a new, unique one as determined by the global\n  mapping, and insert the new (id,instance) pair into that\n  mapping    Delete an existing subtree.  The message must include the unique\n  ID of the tree to delete.  Remove it from the global ID mapping\n  as well and erase its ID attribute.  Replace a subtree with a new one.  The message must include the\n  unique ID of the tree to replace and the data defining the\n  replacement (serialized as just described).  Remove the replaced\n  one from the global ID mapping as well and erase its ID attribute.    Even if it is not being run in a background thread (but perhaps was\n   loaded as a module in some command-line app, for instance) it will\n   still expose insert, delete, and replace functions as part of the\n   module's API.  We will call any kind of insertion, removal, or replacement of\n   subtrees of the LDE Document a change event, whether it happened via\n   a message from a parent thread or as a function call to the LDE as a\n   module in a larger app.", 
            "title": "LDE in general"
        }, 
        {
            "location": "/phase0-structures/#notation-in-code", 
            "text": "Ensure that the Structure (and, later, other subclass) constructors are\nsophisticated enough to help us build LDE Documents easily in the unit\ntesting suite, like so:  Structure(\n    FormalSystem(\n        Rule(\n             function ( step ) { return { valid: step.text().length   5, message: 'Boy is this silly.' }; } ,\n        ).attr( { name :  silly rule  } )\n    ),\n    AtomicExpression(  yay  ).attr( { id : 1 } ),\n    AtomicExpression(  silly rule  ).attr( {  outgoing edges  : [ { targetId : 1, type :  reason  } ] ),\n    AtomicExpression(  oh rats  ).attr( { id : 2 } ),\n    AtomicExpression(  silly rule  ).attr( {  outgoing edges  : [ { targetId : 2, type :  reason  } ] )\n)  or even  Structure(\n    FormalSystem(\n        Rule(\n             function ( step ) { return { valid: step.text().length   5, message: 'Boy is this silly.' }; } ,\n        ).attr( { name :  silly rule  } )\n    ),\n    AtomicExpression(  yay  ).attr( { id : 1 } ),\n    AtomicExpression(  silly rule  ).attr( {  reason for  : 1 } ),\n    AtomicExpression(  oh rats  ).attr( { id : 2 } ),\n    AtomicExpression(  silly rule  ).attr( {  reason for  : 2 } )\n)  or even  Structure(\n    FormalSystem(\n        Rule(\n             function ( step ) { return { valid: step.text().length   5, message: 'Boy is this silly.' }; } ,\n        ).attr( { name :  silly rule  } )\n    ),\n    AtomicExpression(  yay  ),\n    AtomicExpression(  silly rule  ).attr( {  reason for  :  previous  } ),\n    AtomicExpression(  oh rats  ),\n    AtomicExpression(  silly rule  ).attr( {  reason for  :  previous  } )\n)", 
            "title": "Notation in code"
        }, 
        {
            "location": "/phase1-validation/", 
            "text": "LDE Design Phase 1: Basic Validation\n\n\nContent coming soon.", 
            "title": "Phase 1, Basic Validation"
        }, 
        {
            "location": "/phase1-validation/#lde-design-phase-1-basic-validation", 
            "text": "Content coming soon.", 
            "title": "LDE Design Phase 1: Basic Validation"
        }, 
        {
            "location": "/phase1a-client/", 
            "text": "LDE Design Phase 1A: The Client\n\n\nContent coming soon.", 
            "title": "Phase 1A, The Client"
        }, 
        {
            "location": "/phase1a-client/#lde-design-phase-1a-the-client", 
            "text": "Content coming soon.", 
            "title": "LDE Design Phase 1A: The Client"
        }, 
        {
            "location": "/phase1b-dependencies/", 
            "text": "LDE Design Phase 1B: Dependencies\n\n\nContent coming soon.", 
            "title": "Phase 1B, Dependencies"
        }, 
        {
            "location": "/phase1b-dependencies/#lde-design-phase-1b-dependencies", 
            "text": "Content coming soon.", 
            "title": "LDE Design Phase 1B: Dependencies"
        }, 
        {
            "location": "/phase1c-background/", 
            "text": "LDE Design Phase 1C: Background Queue\n\n\nContent coming soon.", 
            "title": "Phase 1C, Background Queue"
        }, 
        {
            "location": "/phase1c-background/#lde-design-phase-1c-background-queue", 
            "text": "Content coming soon.", 
            "title": "LDE Design Phase 1C: Background Queue"
        }, 
        {
            "location": "/phase2-strings/", 
            "text": "LDE Design Phase 2: String Matching\n\n\nContent coming soon.", 
            "title": "Phase 2, String Matching"
        }, 
        {
            "location": "/phase2-strings/#lde-design-phase-2-string-matching", 
            "text": "Content coming soon.", 
            "title": "LDE Design Phase 2: String Matching"
        }, 
        {
            "location": "/phase3-theorems/", 
            "text": "LDE Design Phase 3: Theorems and Proofs\n\n\nContent coming soon.", 
            "title": "Phase 3, Theorems and Proofs"
        }, 
        {
            "location": "/phase3-theorems/#lde-design-phase-3-theorems-and-proofs", 
            "text": "Content coming soon.", 
            "title": "LDE Design Phase 3: Theorems and Proofs"
        }, 
        {
            "location": "/phase4-expressions/", 
            "text": "LDE Design Phase 4: Expressions\n\n\nContent coming soon.", 
            "title": "Phase 4, Expression Trees"
        }, 
        {
            "location": "/phase4-expressions/#lde-design-phase-4-expressions", 
            "text": "Content coming soon.", 
            "title": "LDE Design Phase 4: Expressions"
        }, 
        {
            "location": "/phase5-parsing/", 
            "text": "LDE Design Phase 5: Parsing\n\n\nContent coming soon.", 
            "title": "Phase 5, Parsing Rules"
        }, 
        {
            "location": "/phase5-parsing/#lde-design-phase-5-parsing", 
            "text": "Content coming soon.", 
            "title": "LDE Design Phase 5: Parsing"
        }, 
        {
            "location": "/phase6-declarations/", 
            "text": "LDE Design Phase 6: Declarations\n\n\nContent coming soon.", 
            "title": "Phase 6, Declarations"
        }, 
        {
            "location": "/phase6-declarations/#lde-design-phase-6-declarations", 
            "text": "Content coming soon.", 
            "title": "LDE Design Phase 6: Declarations"
        }, 
        {
            "location": "/phase7-features/", 
            "text": "LDE Design Phase 7: Features\n\n\nContent coming soon.", 
            "title": "Phase 7, Bonus Features"
        }, 
        {
            "location": "/phase7-features/#lde-design-phase-7-features", 
            "text": "Content coming soon.", 
            "title": "LDE Design Phase 7: Features"
        }, 
        {
            "location": "/ideas/", 
            "text": "LDE Design Ideas\n\n\nContent coming soon.", 
            "title": "Ideas"
        }, 
        {
            "location": "/ideas/#lde-design-ideas", 
            "text": "Content coming soon.", 
            "title": "LDE Design Ideas"
        }
    ]
}