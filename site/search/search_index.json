{
    "docs": [
        {
            "location": "/", 
            "text": "The Lurch Deductive Engine (LDE)\n\n\nThis documentation site contains the design of the LDE.\n\n\nWe will implement that design, and as we do so, the various phases of\ndevelopment (accessible from the navigation menu above) will be converted\nfrom pages describing the plan into pages describing the completed API.\n\n\nUse the menu at the top of this site to find content.\n\n\nSee the source code repository here.", 
            "title": "Home"
        }, 
        {
            "location": "/#the-lurch-deductive-engine-lde", 
            "text": "This documentation site contains the design of the LDE.  We will implement that design, and as we do so, the various phases of\ndevelopment (accessible from the navigation menu above) will be converted\nfrom pages describing the plan into pages describing the completed API.  Use the menu at the top of this site to find content.  See the source code repository here.", 
            "title": "The Lurch Deductive Engine (LDE)"
        }, 
        {
            "location": "/design-overview/", 
            "text": "LDE Design Overview\n\n\nThis page lists the design principles adopted by the Lurch team to date\nregarding the LDE, with reasons and explanations for each.  This document\ncan be used as reference, and to guide development, but it may also be\nchanged as better ideas come along.\n\n\nTo see the specific phases of development planned for the LDE, and what's\ncompleted, use the \"Phases\" menu above.\n\n\nElegance and Simplicity\n\n\nThese are of utmost importance, because\n\n\n\n\nthey make Lurch easier to explain to students or in an Advanced User's\n   Guide (AUG),\n\n\nthey make Lurch easier to test because it has fewer unusual corner cases\n   or special handling of odd circumstances,\n\n\nthey make Lurch easier to implement for the same reason, and\n\n\nthey make it easier for us to be confident that our designs are good,\n   because they're easier to hold in your head and grok all at once.\n\n\n\n\nFeedback and Validation\n\n\n\n\nThe primary purpose of the Lurch application is to give feedback to the\n   user about the work they type into their document.\n\n\nBecause this will often involve validating steps of work in a proof, we\n   may use the terms \"feedback\" and \"validation\" interchangeably, even\n   though technically validation is just a particular type of feedback\n   (though the most common type in our case).\n\n\nOne-Pass Validation (OPV)\n is a paradigm in which, whenever the app\n   needs to update feedback in response to changes made by the user, it\n   does so by reprocessing every bit of meaningful content from scratch, in\n   one (large, possibly time-consuming) pass over the whole document.\n\n\nReal-Time Validation (RTV)\n is a paradigm in which, whenever the app\n   needs to update feedback in response to changes made by the user, it\n   attempts to re-use as much information from previous validation as\n   possible, only updating those portions of it that need updating in\n   response to the specific change the user just made.  Thus RTV is\n   trickier to design and implement than OPV, but more efficient at\n   run-time.\n\n\nAn important concept for our test suite is that any RTV design can be\n   converted to an OPV design trivially, and then used for comparison\n   testing.  Simply replace all sophisticated RTV-style change event\n   handlers with OPV-style ones, that mark the entire document as needing\n   reprocessing.  Then any potential change that can be made to the user's\n   document can be run through each of these engines in parallel, and the\n   results compared for equivalence.\n\n\nNote that the choice of OPV vs. RTV is independent of the choice of\n   manual validation vs. automatic validation.  RTV certainly makes\n   automatic validation nicer, and thus makes manual validation less\n   appealing, but you could choose anything from among\n   \n\\{\\text{OPV},\\text{RTV}\\}\\times\\{\\text{auto},\\text{manual}\\}\n.\n\n\n\n\nLDE and UI\n\n\n\n\nWe have a paradigm in which the UI is exactly that (user interface) and\n   the LDE (Lurch Deductive Engine) is the brain that operates in one or\n   more background threads, processing what the user has given the app\n   through the UI.\n\n\nWe aim to implement every feature in the LDE if possible, but implement\n   in the UI only those features that can't be implemented in the LDE.\n   Here, \"if possible\" means that it would not break the model-view\n   paradigm to implement it in the LDE (i.e., the LDE wouldn't need to\n   speak HTML).  Reasons for this:\n\n\nThe LDE will be implemented in pure JS, no DOM, so that it can be\n  used in a WebWorker and in the unit testing suite.\n\n\nTherefore the bigger the LDE is, the more of our code has been\n  subject to rigorous unit tests.\n\n\nAnd the bigger the LDE is, the more of our code is run out of the UX\n  thread, and thus the more responsive our app is.\n\n\n\n\n\n\nThe decisions recorded here are almost entirely about the design of the\n   LDE, not the UI.\n\n\n\n\nStructures\n\n\n\n\nDefine a \nstructure\n to be the basic unit of meaning in the LDE.\n\n\nThis includes document-level structures such as a section,\n  subsection, proof, subproof, etc., which are analogous to block-level\n  items like DIV or P in HTML, and \n\\begin{X}...\\end{X}\n in LaTeX.\n\n\nBut it also includes inline structures (SPANs in HTML, \n\\foo{...}\n or\n  \n$...$\n in LaTeX).\n\n\nStructures can be nested acyclically.\n\n\n\n\n\n\nExamples of types of structures that we may choose to define later:\n\n\nProofs/Subproofs, with one specific flavor of it being the kind that\n  declares a variable first\n\n\nDefinitions of rules, axioms, language rules\n\n\nFormal systems (or \"mathematical topics\")\n\n\nTheorems and pairing of them with proofs\n\n\nExpressions\n\n\nMaybe variables will be declared by based on placing a variable\n  inside an expression by itself, at the head of a variable declaration\n  subproof, or maybe by creating a new structure type for variable\n  declarations, or maybe something else\n\n\nHomework problems\n\n\nExamples (an environment in which anything you declare ends its scope\n  at the end of the example, no matter what it was)\n\n\n\n\n\n\nThe set of structure types should equal the set of common mathematical\n   structures that mathematics students should be learning anyway, and they\n   should behave the same in Lurch as in mathematics.  This ensures that\n   Lurch doesn't add to the mathematics learning curve in this sense.\n\n\nNot every structure is permitted to contain every other type of\n   structure.  But such rules are enforced through validation, which we\n   will not be defining for some time yet, so this comment is just a\n   preview of what's to come.  For instance, expressions can contain only\n   other expressions.\n\n\nAt some later point, we may care about the meanings of structures, so\n   that they can be used as premises in proofs.  At such a time, we will\n   ensure that a structure's meaning includes the unjustified steps in the\n   structure (which function as premises), the final step in the structure\n   (which functions as its conclusion), any variables declared within it\n   (which are bound in it), and so on, but it is not necessary to define\n   those details yet.  I mention them here merely so that the idea is not\n   lost.\n\n\n\n\nAccessibility\n\n\n\n\nA structure A is accessible to a structure B if some ancestor structure\n   of B (possibly B itself) is a sibling of A, but A is the (strictly)\n   earlier of the two siblings within their parent structure.\n\n\nEquivalently, we can speak of \"scope\" rather than accessibility.  The\n   scope of a structure A is all later siblings of A in the same parent,\n   along with all their descendants.  Thus B is in the scope of A iff A is\n   accessible to B.\n\n\n\n\nAttributes\n\n\n\n\nEvery structure contains a key-value dictionary called \nexternal\n   attributes,\n which are read-only from the point of view of the LDE, and\n   are read-write from the point of view of the UI.  They are called\n   \"external\" because, from the LDE's point of view, they come from\n   elsewhere (the UI).\n\n\nEvery structure contains a key-value dictionary called \ncomputed\n   attributes,\n which are read-only from the point of view of the UI, and\n   are read-write from the point of view of the LDE.  They are called\n   \"computed\" because the LDE's job is to compute stuff, which it stores in\n   these attributes.\n\n\nThese two dictionaries are disjoint.  It is possible for a single key k\n   to have one value in the one dictionary, and another value in the other\n   dictionary.\n\n\n\n\nDocument\n\n\n\n\nThe entire document will be represented to the LDE as a single\n   structure, usually with a nonzero number of inner structures.\n\n\nWe call the representation of the entire document as a structure the LDE\n   Document, a phrase chosen to connote \"the LDE's view of the document,\n   not the one the user sees in the UI.\"\n\n\nOne main job of the UI is to convert from what the user sees into the\n   LDE Document.\n\n\nSo to the list of structure types above, add \"Document.\"\n\n\nThe entire LDE Document data structure will live inside the LDE module.\n   In the main Lurch app, this implies that the LDE Document will be stored\n   in the background thread where the LDE runs, not in the UI.  Thus the UI\n   will communicate across threads to create the LDE Document.  Details on\n   this later.\n\n\n\n\nSome brief UI comments\n\n\n\n\nMost of the purpose of the UI will be to convert the HTML document the\n   user sees into the LDE Document the LDE processes, then to show the user\n   in the HTML document and feedback the LDE sends back.\n\n\nIn service to that purpose, the UI contains many (largely independent\n  and usually small) features for encoding the HTML document into the\n  LDE Document.\n\n\nExamples include conventions for processing groups, connections,\n  numbered lists, section headings, finding meaning in text through\n  regular expressions, and the meanings of various LaTeX-like\n  \n\\shortcuts\n.\n\n\nA document author chooses which subset of these features to enable by\n  making choices in the document settings dialog.  Those settings are\n  stored in document metadata, and propagate to dependencies (defined\n  below).\n\n\nThe UI will have very little hard-coded (i.e., non-customizable)\n  procedures for interpreting the HTML document into the LDE document;\n  the settings above are highly choosable by the user.\n\n\nThe only constrained interpretation conventions (i.e., few or no\n  options for changing the interpretation) would be those that have\n  mathematical names, such as \"proof,\" which have a specific meaning\n  that it would be educationally counterproductive to interpret another\n  way.\n\n\nIn addition, we may choose a specific set of document settings to use\n  throughout the standard libraries that ship with Lurch, to show best\n  practices and help users with consistency and predictability.\n\n\n\n\n\n\nOther UI details:\n\n\nBecause we have a UI that allows users to make connections among\n  groups, the structures in the hierarchy may include, among their\n  external attributes, a binary, edge-labeled multigraph.  (Note that\n  this does not require that every connection in the HTML document\n  become two Structures in the LDE Document with attributes connecting\n  them.  Nor does it stipulate that some concept--such as\n  labeling--that we might decide to represent as part of this\n  multigraph can't also be represented sometimes in another way as\n  well.)\n\n\nIf we require the LDE to send a signal when validation completes,\n  then we can make a UI setting of whether to show feedback as the\n  feedback arrives, or only after the \"all validation complete\" signal\n  arrives (and thus feedback has stabilized).\n\n\n\n\n\n\n\n\nStructures are OOP Objects\n\n\n\n\nA structure exposes a set of data and methods about its internal state\n   to the rest of the app, in much the same way as Objects in OOP do, with\n   the type of structure (from the list above, e.g., Theorem or Example)\n   functioning as the \"class\" of the Object.\n\n\nSome methods in a structure will be time-intensive to run, and thus\n   should use an asynchronous paradigm, queueing the tasks for running when\n   the LDE thread has time.  The most time-intensive tasks, such as\n   matching and parsing, may be delegated to yet other background threads\n   by the LDE thread.\n\n\n\n\nExporting data from structures\n\n\n\n\nHere is an important example method that all structures should have\n   (though each class may implement it differently):\n\n\nA method that reports which structures (usually child structures of\n  A), if any, are to be made accessible to any structure B in the scope\n  of A (thus changing the normal scoping rules).\n\n\nThe flexibility inherent in the vagueness of this exporting notion is\n  useful.  For instance, a single theorem in the document might be\n  encoded in the LDE document as having many children, some of which\n  are its various interpretations as a rule of inference, and export\n  them all, so that any can be used/cited later.\n\n\nNote that the exports method need not copy child structures directly\n  for exporting.  It may combine/manipulate/compute structures to\n  export based on its children in any way.  Thus \"scope\" is a simple\n  and clean definition, which this function sort of indirectly extends.\n\n\n\n\n\n\nWe will define much of the functionality of the LDE as the various\n   structures in the document calling methods in one another, which is\n   simple and elegant.  But it requires that we carefully track and cache\n   the clean/dirty status of each structure, to retain efficiency.\n\n\n\n\nDependencies as a special case\n\n\n\n\nThe current paradigm (already implemented) in webLurch is that a\n   dependency must specify what data it exports to any document that\n   depends on it.\n\n\nSuch data will be stored in the dependency document's metadata, so that\n   documents depending on it can easily import it.  It will include\n   anything that the dependency imported from its dependencies, and so on\n   to arbitrary depth.\n\n\nBecause we now require every structure to know what it exports to later\n   structures, the question of what a document exports is simply a special\n   case of that.  The document is itself a structure, and thus it can\n   already answer the \"what does this document export?\" question.\n\n\nRecall from above that one of the pieces of data that a document will\n   export is its document settings, as described earlier.\n\n\n\n\nDesign Phases\n\n\n\n\nThe question, \"Which structure should be designed first?\" is tricky\n   because each structure is rather complex, and they're rather\n   interdependent.\n\n\nOne approach would be to design each structure incrementally, adding\n   features in phases.\n\n\nThus we might begin with an LDE implementation that has just a few\n   features for a few structure types, and yet is sufficient for building\n   very simply Lurch libraries.\n\n\nThis lets us build familiarity and knowledge as we do the design, so\n   we're better at it by the time we get to the hard stuff.\n\n\nPhases 2, 3, and so on can add features and structure types, thus\n   enabling more and more sophisticated Lurch libraries, until we have\n   reached the level of power that supports a first proof course.\n\n\n\n\nSee other documentation on this site for the contents of each design phase.", 
            "title": "Overview"
        }, 
        {
            "location": "/design-overview/#lde-design-overview", 
            "text": "This page lists the design principles adopted by the Lurch team to date\nregarding the LDE, with reasons and explanations for each.  This document\ncan be used as reference, and to guide development, but it may also be\nchanged as better ideas come along.  To see the specific phases of development planned for the LDE, and what's\ncompleted, use the \"Phases\" menu above.", 
            "title": "LDE Design Overview"
        }, 
        {
            "location": "/design-overview/#elegance-and-simplicity", 
            "text": "These are of utmost importance, because   they make Lurch easier to explain to students or in an Advanced User's\n   Guide (AUG),  they make Lurch easier to test because it has fewer unusual corner cases\n   or special handling of odd circumstances,  they make Lurch easier to implement for the same reason, and  they make it easier for us to be confident that our designs are good,\n   because they're easier to hold in your head and grok all at once.", 
            "title": "Elegance and Simplicity"
        }, 
        {
            "location": "/design-overview/#feedback-and-validation", 
            "text": "The primary purpose of the Lurch application is to give feedback to the\n   user about the work they type into their document.  Because this will often involve validating steps of work in a proof, we\n   may use the terms \"feedback\" and \"validation\" interchangeably, even\n   though technically validation is just a particular type of feedback\n   (though the most common type in our case).  One-Pass Validation (OPV)  is a paradigm in which, whenever the app\n   needs to update feedback in response to changes made by the user, it\n   does so by reprocessing every bit of meaningful content from scratch, in\n   one (large, possibly time-consuming) pass over the whole document.  Real-Time Validation (RTV)  is a paradigm in which, whenever the app\n   needs to update feedback in response to changes made by the user, it\n   attempts to re-use as much information from previous validation as\n   possible, only updating those portions of it that need updating in\n   response to the specific change the user just made.  Thus RTV is\n   trickier to design and implement than OPV, but more efficient at\n   run-time.  An important concept for our test suite is that any RTV design can be\n   converted to an OPV design trivially, and then used for comparison\n   testing.  Simply replace all sophisticated RTV-style change event\n   handlers with OPV-style ones, that mark the entire document as needing\n   reprocessing.  Then any potential change that can be made to the user's\n   document can be run through each of these engines in parallel, and the\n   results compared for equivalence.  Note that the choice of OPV vs. RTV is independent of the choice of\n   manual validation vs. automatic validation.  RTV certainly makes\n   automatic validation nicer, and thus makes manual validation less\n   appealing, but you could choose anything from among\n    \\{\\text{OPV},\\text{RTV}\\}\\times\\{\\text{auto},\\text{manual}\\} .", 
            "title": "Feedback and Validation"
        }, 
        {
            "location": "/design-overview/#lde-and-ui", 
            "text": "We have a paradigm in which the UI is exactly that (user interface) and\n   the LDE (Lurch Deductive Engine) is the brain that operates in one or\n   more background threads, processing what the user has given the app\n   through the UI.  We aim to implement every feature in the LDE if possible, but implement\n   in the UI only those features that can't be implemented in the LDE.\n   Here, \"if possible\" means that it would not break the model-view\n   paradigm to implement it in the LDE (i.e., the LDE wouldn't need to\n   speak HTML).  Reasons for this:  The LDE will be implemented in pure JS, no DOM, so that it can be\n  used in a WebWorker and in the unit testing suite.  Therefore the bigger the LDE is, the more of our code has been\n  subject to rigorous unit tests.  And the bigger the LDE is, the more of our code is run out of the UX\n  thread, and thus the more responsive our app is.    The decisions recorded here are almost entirely about the design of the\n   LDE, not the UI.", 
            "title": "LDE and UI"
        }, 
        {
            "location": "/design-overview/#structures", 
            "text": "Define a  structure  to be the basic unit of meaning in the LDE.  This includes document-level structures such as a section,\n  subsection, proof, subproof, etc., which are analogous to block-level\n  items like DIV or P in HTML, and  \\begin{X}...\\end{X}  in LaTeX.  But it also includes inline structures (SPANs in HTML,  \\foo{...}  or\n   $...$  in LaTeX).  Structures can be nested acyclically.    Examples of types of structures that we may choose to define later:  Proofs/Subproofs, with one specific flavor of it being the kind that\n  declares a variable first  Definitions of rules, axioms, language rules  Formal systems (or \"mathematical topics\")  Theorems and pairing of them with proofs  Expressions  Maybe variables will be declared by based on placing a variable\n  inside an expression by itself, at the head of a variable declaration\n  subproof, or maybe by creating a new structure type for variable\n  declarations, or maybe something else  Homework problems  Examples (an environment in which anything you declare ends its scope\n  at the end of the example, no matter what it was)    The set of structure types should equal the set of common mathematical\n   structures that mathematics students should be learning anyway, and they\n   should behave the same in Lurch as in mathematics.  This ensures that\n   Lurch doesn't add to the mathematics learning curve in this sense.  Not every structure is permitted to contain every other type of\n   structure.  But such rules are enforced through validation, which we\n   will not be defining for some time yet, so this comment is just a\n   preview of what's to come.  For instance, expressions can contain only\n   other expressions.  At some later point, we may care about the meanings of structures, so\n   that they can be used as premises in proofs.  At such a time, we will\n   ensure that a structure's meaning includes the unjustified steps in the\n   structure (which function as premises), the final step in the structure\n   (which functions as its conclusion), any variables declared within it\n   (which are bound in it), and so on, but it is not necessary to define\n   those details yet.  I mention them here merely so that the idea is not\n   lost.", 
            "title": "Structures"
        }, 
        {
            "location": "/design-overview/#accessibility", 
            "text": "A structure A is accessible to a structure B if some ancestor structure\n   of B (possibly B itself) is a sibling of A, but A is the (strictly)\n   earlier of the two siblings within their parent structure.  Equivalently, we can speak of \"scope\" rather than accessibility.  The\n   scope of a structure A is all later siblings of A in the same parent,\n   along with all their descendants.  Thus B is in the scope of A iff A is\n   accessible to B.", 
            "title": "Accessibility"
        }, 
        {
            "location": "/design-overview/#attributes", 
            "text": "Every structure contains a key-value dictionary called  external\n   attributes,  which are read-only from the point of view of the LDE, and\n   are read-write from the point of view of the UI.  They are called\n   \"external\" because, from the LDE's point of view, they come from\n   elsewhere (the UI).  Every structure contains a key-value dictionary called  computed\n   attributes,  which are read-only from the point of view of the UI, and\n   are read-write from the point of view of the LDE.  They are called\n   \"computed\" because the LDE's job is to compute stuff, which it stores in\n   these attributes.  These two dictionaries are disjoint.  It is possible for a single key k\n   to have one value in the one dictionary, and another value in the other\n   dictionary.", 
            "title": "Attributes"
        }, 
        {
            "location": "/design-overview/#document", 
            "text": "The entire document will be represented to the LDE as a single\n   structure, usually with a nonzero number of inner structures.  We call the representation of the entire document as a structure the LDE\n   Document, a phrase chosen to connote \"the LDE's view of the document,\n   not the one the user sees in the UI.\"  One main job of the UI is to convert from what the user sees into the\n   LDE Document.  So to the list of structure types above, add \"Document.\"  The entire LDE Document data structure will live inside the LDE module.\n   In the main Lurch app, this implies that the LDE Document will be stored\n   in the background thread where the LDE runs, not in the UI.  Thus the UI\n   will communicate across threads to create the LDE Document.  Details on\n   this later.", 
            "title": "Document"
        }, 
        {
            "location": "/design-overview/#some-brief-ui-comments", 
            "text": "Most of the purpose of the UI will be to convert the HTML document the\n   user sees into the LDE Document the LDE processes, then to show the user\n   in the HTML document and feedback the LDE sends back.  In service to that purpose, the UI contains many (largely independent\n  and usually small) features for encoding the HTML document into the\n  LDE Document.  Examples include conventions for processing groups, connections,\n  numbered lists, section headings, finding meaning in text through\n  regular expressions, and the meanings of various LaTeX-like\n   \\shortcuts .  A document author chooses which subset of these features to enable by\n  making choices in the document settings dialog.  Those settings are\n  stored in document metadata, and propagate to dependencies (defined\n  below).  The UI will have very little hard-coded (i.e., non-customizable)\n  procedures for interpreting the HTML document into the LDE document;\n  the settings above are highly choosable by the user.  The only constrained interpretation conventions (i.e., few or no\n  options for changing the interpretation) would be those that have\n  mathematical names, such as \"proof,\" which have a specific meaning\n  that it would be educationally counterproductive to interpret another\n  way.  In addition, we may choose a specific set of document settings to use\n  throughout the standard libraries that ship with Lurch, to show best\n  practices and help users with consistency and predictability.    Other UI details:  Because we have a UI that allows users to make connections among\n  groups, the structures in the hierarchy may include, among their\n  external attributes, a binary, edge-labeled multigraph.  (Note that\n  this does not require that every connection in the HTML document\n  become two Structures in the LDE Document with attributes connecting\n  them.  Nor does it stipulate that some concept--such as\n  labeling--that we might decide to represent as part of this\n  multigraph can't also be represented sometimes in another way as\n  well.)  If we require the LDE to send a signal when validation completes,\n  then we can make a UI setting of whether to show feedback as the\n  feedback arrives, or only after the \"all validation complete\" signal\n  arrives (and thus feedback has stabilized).", 
            "title": "Some brief UI comments"
        }, 
        {
            "location": "/design-overview/#structures-are-oop-objects", 
            "text": "A structure exposes a set of data and methods about its internal state\n   to the rest of the app, in much the same way as Objects in OOP do, with\n   the type of structure (from the list above, e.g., Theorem or Example)\n   functioning as the \"class\" of the Object.  Some methods in a structure will be time-intensive to run, and thus\n   should use an asynchronous paradigm, queueing the tasks for running when\n   the LDE thread has time.  The most time-intensive tasks, such as\n   matching and parsing, may be delegated to yet other background threads\n   by the LDE thread.", 
            "title": "Structures are OOP Objects"
        }, 
        {
            "location": "/design-overview/#exporting-data-from-structures", 
            "text": "Here is an important example method that all structures should have\n   (though each class may implement it differently):  A method that reports which structures (usually child structures of\n  A), if any, are to be made accessible to any structure B in the scope\n  of A (thus changing the normal scoping rules).  The flexibility inherent in the vagueness of this exporting notion is\n  useful.  For instance, a single theorem in the document might be\n  encoded in the LDE document as having many children, some of which\n  are its various interpretations as a rule of inference, and export\n  them all, so that any can be used/cited later.  Note that the exports method need not copy child structures directly\n  for exporting.  It may combine/manipulate/compute structures to\n  export based on its children in any way.  Thus \"scope\" is a simple\n  and clean definition, which this function sort of indirectly extends.    We will define much of the functionality of the LDE as the various\n   structures in the document calling methods in one another, which is\n   simple and elegant.  But it requires that we carefully track and cache\n   the clean/dirty status of each structure, to retain efficiency.", 
            "title": "Exporting data from structures"
        }, 
        {
            "location": "/design-overview/#dependencies-as-a-special-case", 
            "text": "The current paradigm (already implemented) in webLurch is that a\n   dependency must specify what data it exports to any document that\n   depends on it.  Such data will be stored in the dependency document's metadata, so that\n   documents depending on it can easily import it.  It will include\n   anything that the dependency imported from its dependencies, and so on\n   to arbitrary depth.  Because we now require every structure to know what it exports to later\n   structures, the question of what a document exports is simply a special\n   case of that.  The document is itself a structure, and thus it can\n   already answer the \"what does this document export?\" question.  Recall from above that one of the pieces of data that a document will\n   export is its document settings, as described earlier.", 
            "title": "Dependencies as a special case"
        }, 
        {
            "location": "/design-overview/#design-phases", 
            "text": "The question, \"Which structure should be designed first?\" is tricky\n   because each structure is rather complex, and they're rather\n   interdependent.  One approach would be to design each structure incrementally, adding\n   features in phases.  Thus we might begin with an LDE implementation that has just a few\n   features for a few structure types, and yet is sufficient for building\n   very simply Lurch libraries.  This lets us build familiarity and knowledge as we do the design, so\n   we're better at it by the time we get to the hard stuff.  Phases 2, 3, and so on can add features and structure types, thus\n   enabling more and more sophisticated Lurch libraries, until we have\n   reached the level of power that supports a first proof course.   See other documentation on this site for the contents of each design phase.", 
            "title": "Design Phases"
        }, 
        {
            "location": "/phase1-structures/", 
            "text": "We have designed the work on the Lurch Deductive Engine (LDE) to progress in\nphases.  The idea is that each phase ends with a completed whole that can be\ntested in that state, and that provides more features than the previous\nstate did.  By the time the final phase is complete, the LDE will be a\nrobust and useful product.\n\n\nLDE Design Phase 1: Structures\n\n\nContent\n\n\nIn this phase, we just design the generic Structure class on which\neverything else will depend, and the infrastructure of the LDE itself.\n\n\nGoal\n\n\nAt the end of this phase, we could write unit tests of the whole Structure\nclass and its LDE context, thus guaranteeing that all later phases rest on a\ngood foundation.\n\n\nStatus\n\n\nThis phase has been implemented, and is documented in the API Documentation,\naccessible from the navigation menu at the top of this site.\n\n\nThe Structure module\n\n\nThat module defines a single \nStructure\n class, and has been implemented.\n\nIts API Documentation appears here\n.\n\n\nLDE Module\n\n\nThat module defines several global functions, and has been implemented.\n\nIts API Documentation appears here\n.\n\n\nThere is one task left to implement before this phase is complete:\n\n\nIf the LDE detects that it is being run in a background thread, it will set\nup listeners for messages from the parent thread.  These listeners will\nhandle messages of four types, insert/delete/replace/attribute, mirroring\nthe four functions given above, and calling them internally.", 
            "title": "Phase 1, Structures"
        }, 
        {
            "location": "/phase1-structures/#lde-design-phase-1-structures", 
            "text": "", 
            "title": "LDE Design Phase 1: Structures"
        }, 
        {
            "location": "/phase1-structures/#content", 
            "text": "In this phase, we just design the generic Structure class on which\neverything else will depend, and the infrastructure of the LDE itself.", 
            "title": "Content"
        }, 
        {
            "location": "/phase1-structures/#goal", 
            "text": "At the end of this phase, we could write unit tests of the whole Structure\nclass and its LDE context, thus guaranteeing that all later phases rest on a\ngood foundation.", 
            "title": "Goal"
        }, 
        {
            "location": "/phase1-structures/#status", 
            "text": "This phase has been implemented, and is documented in the API Documentation,\naccessible from the navigation menu at the top of this site.", 
            "title": "Status"
        }, 
        {
            "location": "/phase1-structures/#the-structure-module", 
            "text": "That module defines a single  Structure  class, and has been implemented. Its API Documentation appears here .", 
            "title": "The Structure module"
        }, 
        {
            "location": "/phase1-structures/#lde-module", 
            "text": "That module defines several global functions, and has been implemented. Its API Documentation appears here .  There is one task left to implement before this phase is complete:  If the LDE detects that it is being run in a background thread, it will set\nup listeners for messages from the parent thread.  These listeners will\nhandle messages of four types, insert/delete/replace/attribute, mirroring\nthe four functions given above, and calling them internally.", 
            "title": "LDE Module"
        }, 
        {
            "location": "/phase2-validation/", 
            "text": "We have designed the work on the Lurch Deductive Engine (LDE) to progress in\nphases.  The idea is that each phase ends with a completed whole that can be\ntested in that state, and that provides more features than the previous\nstate did.  By the time the final phase is complete, the LDE will be a\nrobust and useful product.\n\n\nLDE Design Phase 2: Basic Validation\n\n\nContent\n\n\nThis phase defines:\n\n\n\n\nAtomic expressions (just expressions whose meaning is a string, and\n   contain no other structures)\n\n\nDefinitions of the simplest rule type only: code rules written in\n   JavaScript\n\n\nFormal systems (or \"mathematical topics\", which are structures we can\n   put rules inside of)\n\n\n\n\nGoal\n\n\nThis enables really simple formal systems, like TriX game.\n\n\nWhile the intent is for any of the nontrivial processing tasks to be placed\nin a queue and handled when the CPU has time, I leave that hassle out of the\ncurrent design plans.  A later phase will add support for this.\n\n\nStatus\n\n\nThis phase has not yet been implemented.  Once it has been implemented, its\ncontents will be documented in the API Documentation available from the\nnavigation menu at the top of this site.\n\n\nAtomic expressions\n\n\n\n\nE.goals == [ \"validated\" ]\n\n\nE.validate()\n does this:\n\n\nIf \nE.children().length \n 0\n then\n  \nE.feedback(\"X\",\"only atomic expressions supported so far\")\n\n\nOtherwise \nE.feedback(none,none)\n\n\nE.meaning()\n returns \nE.text()\n, but we may decide not to use a\n  loaded word like \"meaning\" and instead just leave .text() to be\n  called directly, if \n.meaning()\n seems too confusing or\n  philosophically overcommitted\n\n\nE.wasChanged()\n calls \nE.clearComputedAttributes()\n\n\nWe have not yet specified the implementation for\n  \nE.wasInserted/wasRemoved/wasChanged()\n.  Does it need to call\n  \nvalidate()\n in anything?\n\n\n\n\n\n\n\n\nDefinitions of the simplest rules: code-based rules\n\n\n\n\nR.validate()\n does this:\n\n\nIf \nR.attributes().code!=true\n then\n  \nR.feedback(\"X\",\"only code rules are supported so far\")\n\n\nIf \nR.text()\n isn't valid JavaScript code that defines a function,\n  then \nR.feedback(\"X\",\"...\")\n\n\nOtherwise \nR.feedback(\"check\",\"nice code rule, dude\")\n\n\nIn any case, whenever \nR.validate()\n terminates, it calls\n  \nE.clearComputedAttributes()\n for every E in \nR.whatCitesMe()\n.\n\n\n\n\n\n\nExtend \nE.validate()\n, the routine for atomic expressions, by replacing\n   its \"otherwise\" step with these steps:\n\n\nIf \nE.attributes().reason\n doesn't exist, do \nE.feedback(none,none)\n\n  and stop.\n\n\nLet r=\nE.attributes().reason\n.\n\n\nIf \nE.findCited(r)\n is undefined, then\n  \nE.feedback(\"X\",\"no such rule\")\n\n\nLet r=\nE.findCited(r)\n.\n\n\nIf \nr.getComputedAttribute(\"validated\")\n is undefined, then stop\n  here.  When r gets validated, it will trigger a re-validation of E,\n  as in the final bullet point under \nR.validate()\n, above.\n\n\nLet f be the JavaScript function defined in \nr.text()\n and call\n  \nf(E)\n.\n\n\nIf \nf(E)\n ends with an error, then\n  \nE.feedback(\"X\",\"internal rule error\")\n.\n\n\nIf \nf(E)\n doesn't terminate soon, then\n  \nE.feedback(\"X\",\"internal rule error\")\n.\n\n\nIf \nf(E)\n is not a correctly formed validation result object, then\n  \nE.feedback(\"X\",\"internal rule error\")\n.\n\n\nOtherwise \nE.feedback(f(E).type,f(E).message)\n.\n\n\nWe have not yet specified the implementation for\n  \nR.wasInserted/wasRemoved/wasChanged()\n.  Does it need to call\n  \nvalidate()\n in anything?\n\n\n\n\n\n\n\n\nFormal systems (or \"mathematical topics\")\n\n\n\n\nF.exports()\n returns an array composed of these things, in the order\n   they appear in the document:\n\n\nany rule in \nF.children()\n\n\nany element of \nF'.exports()\n for any formal system F' in\n  \nF.children()\n\n\n\n\n\n\nExtend \nS.findCited(n)\n to also check \nF.exports()\n whenever it\n   encounters an accessible formal system\n\n\nExtend \nS.whatCitesMe()\n to also looks at the scope of \nS.parent()\n iff\n   it is a formal system (and its \nparent()\n iff that is a formal system,\n   and so on)\n\n\nWe have not yet specified the implementation for\n   \nS.wasInserted/wasRemoved/wasChanged()\n.  Does it need to call\n   \nvalidate()\n in anything?\n\n\n\n\nUnit testing\n\n\nHow we could do unit testing on this simple LDE:\n\n\n\n\nFire up the LDE so that its document is new and thus blank.\n\n\nSet up a listener for the \"computation finished\" signals from the LDE,\n   storing the results for use in testing.\n\n\nTell the LDE to add three children to the LDE Document: a rule, a step\n   using it correctly, and a step using it incorrectly.\n\n\nWait until we receive the signal that says the LDE has finished\n   computing.\n\n\nExamine the computation results stored in step 2 and verify correct\n   processing of the rule and two steps.\n\n\n\n\nWe might even extend this test with more steps.\n\n\n\n\nSend a signal to the LDE to alter the third child of the document,\n   making it a correct use of the rule.\n\n\nWait for computation to finish and check to be sure it re-validated that\n   step as correct now.", 
            "title": "Phase 2, Basic Validation"
        }, 
        {
            "location": "/phase2-validation/#lde-design-phase-2-basic-validation", 
            "text": "", 
            "title": "LDE Design Phase 2: Basic Validation"
        }, 
        {
            "location": "/phase2-validation/#content", 
            "text": "This phase defines:   Atomic expressions (just expressions whose meaning is a string, and\n   contain no other structures)  Definitions of the simplest rule type only: code rules written in\n   JavaScript  Formal systems (or \"mathematical topics\", which are structures we can\n   put rules inside of)", 
            "title": "Content"
        }, 
        {
            "location": "/phase2-validation/#goal", 
            "text": "This enables really simple formal systems, like TriX game.  While the intent is for any of the nontrivial processing tasks to be placed\nin a queue and handled when the CPU has time, I leave that hassle out of the\ncurrent design plans.  A later phase will add support for this.", 
            "title": "Goal"
        }, 
        {
            "location": "/phase2-validation/#status", 
            "text": "This phase has not yet been implemented.  Once it has been implemented, its\ncontents will be documented in the API Documentation available from the\nnavigation menu at the top of this site.", 
            "title": "Status"
        }, 
        {
            "location": "/phase2-validation/#atomic-expressions", 
            "text": "E.goals == [ \"validated\" ]  E.validate()  does this:  If  E.children().length   0  then\n   E.feedback(\"X\",\"only atomic expressions supported so far\")  Otherwise  E.feedback(none,none)  E.meaning()  returns  E.text() , but we may decide not to use a\n  loaded word like \"meaning\" and instead just leave .text() to be\n  called directly, if  .meaning()  seems too confusing or\n  philosophically overcommitted  E.wasChanged()  calls  E.clearComputedAttributes()  We have not yet specified the implementation for\n   E.wasInserted/wasRemoved/wasChanged() .  Does it need to call\n   validate()  in anything?", 
            "title": "Atomic expressions"
        }, 
        {
            "location": "/phase2-validation/#definitions-of-the-simplest-rules-code-based-rules", 
            "text": "R.validate()  does this:  If  R.attributes().code!=true  then\n   R.feedback(\"X\",\"only code rules are supported so far\")  If  R.text()  isn't valid JavaScript code that defines a function,\n  then  R.feedback(\"X\",\"...\")  Otherwise  R.feedback(\"check\",\"nice code rule, dude\")  In any case, whenever  R.validate()  terminates, it calls\n   E.clearComputedAttributes()  for every E in  R.whatCitesMe() .    Extend  E.validate() , the routine for atomic expressions, by replacing\n   its \"otherwise\" step with these steps:  If  E.attributes().reason  doesn't exist, do  E.feedback(none,none) \n  and stop.  Let r= E.attributes().reason .  If  E.findCited(r)  is undefined, then\n   E.feedback(\"X\",\"no such rule\")  Let r= E.findCited(r) .  If  r.getComputedAttribute(\"validated\")  is undefined, then stop\n  here.  When r gets validated, it will trigger a re-validation of E,\n  as in the final bullet point under  R.validate() , above.  Let f be the JavaScript function defined in  r.text()  and call\n   f(E) .  If  f(E)  ends with an error, then\n   E.feedback(\"X\",\"internal rule error\") .  If  f(E)  doesn't terminate soon, then\n   E.feedback(\"X\",\"internal rule error\") .  If  f(E)  is not a correctly formed validation result object, then\n   E.feedback(\"X\",\"internal rule error\") .  Otherwise  E.feedback(f(E).type,f(E).message) .  We have not yet specified the implementation for\n   R.wasInserted/wasRemoved/wasChanged() .  Does it need to call\n   validate()  in anything?", 
            "title": "Definitions of the simplest rules: code-based rules"
        }, 
        {
            "location": "/phase2-validation/#formal-systems-or-mathematical-topics", 
            "text": "F.exports()  returns an array composed of these things, in the order\n   they appear in the document:  any rule in  F.children()  any element of  F'.exports()  for any formal system F' in\n   F.children()    Extend  S.findCited(n)  to also check  F.exports()  whenever it\n   encounters an accessible formal system  Extend  S.whatCitesMe()  to also looks at the scope of  S.parent()  iff\n   it is a formal system (and its  parent()  iff that is a formal system,\n   and so on)  We have not yet specified the implementation for\n    S.wasInserted/wasRemoved/wasChanged() .  Does it need to call\n    validate()  in anything?", 
            "title": "Formal systems (or \"mathematical topics\")"
        }, 
        {
            "location": "/phase2-validation/#unit-testing", 
            "text": "How we could do unit testing on this simple LDE:   Fire up the LDE so that its document is new and thus blank.  Set up a listener for the \"computation finished\" signals from the LDE,\n   storing the results for use in testing.  Tell the LDE to add three children to the LDE Document: a rule, a step\n   using it correctly, and a step using it incorrectly.  Wait until we receive the signal that says the LDE has finished\n   computing.  Examine the computation results stored in step 2 and verify correct\n   processing of the rule and two steps.   We might even extend this test with more steps.   Send a signal to the LDE to alter the third child of the document,\n   making it a correct use of the rule.  Wait for computation to finish and check to be sure it re-validated that\n   step as correct now.", 
            "title": "Unit testing"
        }, 
        {
            "location": "/phase3-client/", 
            "text": "We have designed the work on the Lurch Deductive Engine (LDE) to progress in\nphases.  The idea is that each phase ends with a completed whole that can be\ntested in that state, and that provides more features than the previous\nstate did.  By the time the final phase is complete, the LDE will be a\nrobust and useful product.\n\n\nLDE Design Phase 3: The Client\n\n\nContent\n\n\nThis phase defines the LDE Client, a thin interface to the LDE defined in a\nseparate module.\n\n\nThe Client maintains the Facade, a shallow copy of the LDE Document that it\nkeeps in sync with it, thus providing an easy API for interacting with the\nLDE.\n\n\nThis page is just a description; it's not actually written in a \"design\" or\n\"how to build\" manner, at least not to the same degree that Phase 2 was.\n\n\nGoal\n\n\nThis phase's work just makes Phase 1's work easier to use for most clients.\n\n\nStatus\n\n\nThis phase has not yet been implemented.  Once it has been implemented, its\ncontents will be documented in the API Documentation available from the\nnavigation menu at the top of this site.\n\n\nApp launch\n\n\nWhen the Client is loaded into memory (say, at app launch) it will create a\nglobal structure that is intended to be a sort of shallow/shadow/fake copy\nof the LDE Document.\n\n\n\n\nBecause it will imitate the structure of the LDE Document, it will be\n   a hierarchy.\n\n\nBut it will not be a hierarchy of Structures, because as we know,\n   Structures do computation, and that's the job of the LDE.  This is\n   just a front-end; it doesn't do anything.\n\n\nSo rather than calling each node in the Client's hierarchy a\n   Structure, I'll call it a \nFacade.\n  This is to emphasize that this\n   hierarchy, stored in the Client (part of the UI) can't do anything at\n   all.  It's picture of what's really going on elsewhere, in the LDE.\n\n\n\n\nBackground threads\n\n\nThe Client can be told about the existence of a background thread that's\nrunning the LDE.\n\n\n\n\nIf it is told about such a thread, then any later\n   insertions/deletions/changes to the Facade hierarchy will immediately\n   be communicated by the Client to that LDE thread as a change event\n   (defined above).\n\n\nThis guarantees that the Facade hierarchy and LDE Document are always\n   in sync:  Because the LDE never alters its hierarchy, messages need\n   propagate in only one direction to guarantee that the two hierarchies\n   are isomorphic.\n\n\n\n\nNo subclasses\n\n\nBecause the nodes in the Facade don't actually do anything, they have no\nsubclasses.\n\n\n\n\nUnlike the Structure class, which it makes sense to subclass so that\n   we can add various features like validation functions and so forth,\n   none of that matters in the Facade.  It ships all that work to\n   someone else.\n\n\nThus every node in the Facade hierarchy is a generic Facade node,\n   storing a dictionary of attributes given to it at construction time,\n   which are precisely the external attributes for that node.\n\n\nThese attributes will have been communicated to the LDE when the\n   Facade node was constructed, and the LDE can use them to figure out\n   how to create a corresponding Structure node on the LDE side (or any\n   subclass of Structure; one attribute should be the class name\n   itself!).\n\n\nBut the point here is that what it means for the Facade to be a\n   shallow/inactive copy of the LDE Document is that:\n\n\nEvery node is just a Facade node, and thus they have no\n  specialized functionality at all.\n\n\nEvery node just stores its attributes, not doing anything with\n  them, unlike on the LDE Document side, which does computation.\n\n\n\n\n\n\n\n\nSerialization\n\n\n\n\nFacade nodes do one thing, actually:  They know how to serialize\n   themselves into JSON, including all their children.\n\n\nThis is so that they can pass themselves across to the LDE for syncing,\n   and so that the entire Facade can be serialized by the UI (later of\n   course) for saving in document metadata.\n\n\n\n\nIDs\n\n\nEach Facade node will be given, at the time it's created, an ID unique\namong all nodes in the Facade hierarchy.\n\n\n\n\nThis unique ID will be part of what's communicated in the change event\n   to the LDE, so that the corresponding Structure created in the LDE can\n   have the same ID.\n\n\nThus future change events from the Client to the LDE can reference nodes\n   in the hierarchy by this common ID system.\n\n\nSimilarly, when the LDE sends out signals about new computed attributes\n   being stored in the LDE Document, it will mention these unique IDs to\n   unambiguously indicate in which node the new computed attribute is\n   stored.\n\n\nThe Client will then store the same computed attribute in the\n   corresponding Facade node, so that it is accessible to the entire UI as\n   well.\n\n\n\n\nUnit testing\n\n\n\n\nVerify that the Facade hierarchy can be built and works independent of\n   the LDE\n\n\nVerify that if you connect it to an LDE background thread, the documents\n   stay in sync\n\n\nVerify that the same tests done in Phase 2 can be done also through this\n   \"API\" to the LDE\n\n\nAll further testing in later phases has the option of using the Client\n   or not, depending on what's best for testing in that particular instance.\n\n\n\n\nExtendability\n\n\n\n\nThe LDE is free to expose to clients any other functionality it sees\n   fit.  That is, interaction with the LDE is not limited to syncing the\n   Facade with the LDE Document and waiting for computed responses.\n\n\nFor instance, one type of response that should only be produced when\n   specifically asked for is a \"verbose feedback\" response, like what we\n   get in the old desktop Lurch by double-clicking a traffic light.  This\n   is too much work to create for every step of work, but should be created\n   only when needed.\n\n\nThus the LDE could expose a computeVerboseFeedback() function that took\n   the unique ID of an LDE Document structure as input and later sent back\n   a message with the corresponding verbose feedback (in HTML form) as the\n   result.", 
            "title": "Phase 3, The Client"
        }, 
        {
            "location": "/phase3-client/#lde-design-phase-3-the-client", 
            "text": "", 
            "title": "LDE Design Phase 3: The Client"
        }, 
        {
            "location": "/phase3-client/#content", 
            "text": "This phase defines the LDE Client, a thin interface to the LDE defined in a\nseparate module.  The Client maintains the Facade, a shallow copy of the LDE Document that it\nkeeps in sync with it, thus providing an easy API for interacting with the\nLDE.  This page is just a description; it's not actually written in a \"design\" or\n\"how to build\" manner, at least not to the same degree that Phase 2 was.", 
            "title": "Content"
        }, 
        {
            "location": "/phase3-client/#goal", 
            "text": "This phase's work just makes Phase 1's work easier to use for most clients.", 
            "title": "Goal"
        }, 
        {
            "location": "/phase3-client/#status", 
            "text": "This phase has not yet been implemented.  Once it has been implemented, its\ncontents will be documented in the API Documentation available from the\nnavigation menu at the top of this site.", 
            "title": "Status"
        }, 
        {
            "location": "/phase3-client/#app-launch", 
            "text": "When the Client is loaded into memory (say, at app launch) it will create a\nglobal structure that is intended to be a sort of shallow/shadow/fake copy\nof the LDE Document.   Because it will imitate the structure of the LDE Document, it will be\n   a hierarchy.  But it will not be a hierarchy of Structures, because as we know,\n   Structures do computation, and that's the job of the LDE.  This is\n   just a front-end; it doesn't do anything.  So rather than calling each node in the Client's hierarchy a\n   Structure, I'll call it a  Facade.   This is to emphasize that this\n   hierarchy, stored in the Client (part of the UI) can't do anything at\n   all.  It's picture of what's really going on elsewhere, in the LDE.", 
            "title": "App launch"
        }, 
        {
            "location": "/phase3-client/#background-threads", 
            "text": "The Client can be told about the existence of a background thread that's\nrunning the LDE.   If it is told about such a thread, then any later\n   insertions/deletions/changes to the Facade hierarchy will immediately\n   be communicated by the Client to that LDE thread as a change event\n   (defined above).  This guarantees that the Facade hierarchy and LDE Document are always\n   in sync:  Because the LDE never alters its hierarchy, messages need\n   propagate in only one direction to guarantee that the two hierarchies\n   are isomorphic.", 
            "title": "Background threads"
        }, 
        {
            "location": "/phase3-client/#no-subclasses", 
            "text": "Because the nodes in the Facade don't actually do anything, they have no\nsubclasses.   Unlike the Structure class, which it makes sense to subclass so that\n   we can add various features like validation functions and so forth,\n   none of that matters in the Facade.  It ships all that work to\n   someone else.  Thus every node in the Facade hierarchy is a generic Facade node,\n   storing a dictionary of attributes given to it at construction time,\n   which are precisely the external attributes for that node.  These attributes will have been communicated to the LDE when the\n   Facade node was constructed, and the LDE can use them to figure out\n   how to create a corresponding Structure node on the LDE side (or any\n   subclass of Structure; one attribute should be the class name\n   itself!).  But the point here is that what it means for the Facade to be a\n   shallow/inactive copy of the LDE Document is that:  Every node is just a Facade node, and thus they have no\n  specialized functionality at all.  Every node just stores its attributes, not doing anything with\n  them, unlike on the LDE Document side, which does computation.", 
            "title": "No subclasses"
        }, 
        {
            "location": "/phase3-client/#serialization", 
            "text": "Facade nodes do one thing, actually:  They know how to serialize\n   themselves into JSON, including all their children.  This is so that they can pass themselves across to the LDE for syncing,\n   and so that the entire Facade can be serialized by the UI (later of\n   course) for saving in document metadata.", 
            "title": "Serialization"
        }, 
        {
            "location": "/phase3-client/#ids", 
            "text": "Each Facade node will be given, at the time it's created, an ID unique\namong all nodes in the Facade hierarchy.   This unique ID will be part of what's communicated in the change event\n   to the LDE, so that the corresponding Structure created in the LDE can\n   have the same ID.  Thus future change events from the Client to the LDE can reference nodes\n   in the hierarchy by this common ID system.  Similarly, when the LDE sends out signals about new computed attributes\n   being stored in the LDE Document, it will mention these unique IDs to\n   unambiguously indicate in which node the new computed attribute is\n   stored.  The Client will then store the same computed attribute in the\n   corresponding Facade node, so that it is accessible to the entire UI as\n   well.", 
            "title": "IDs"
        }, 
        {
            "location": "/phase3-client/#unit-testing", 
            "text": "Verify that the Facade hierarchy can be built and works independent of\n   the LDE  Verify that if you connect it to an LDE background thread, the documents\n   stay in sync  Verify that the same tests done in Phase 2 can be done also through this\n   \"API\" to the LDE  All further testing in later phases has the option of using the Client\n   or not, depending on what's best for testing in that particular instance.", 
            "title": "Unit testing"
        }, 
        {
            "location": "/phase3-client/#extendability", 
            "text": "The LDE is free to expose to clients any other functionality it sees\n   fit.  That is, interaction with the LDE is not limited to syncing the\n   Facade with the LDE Document and waiting for computed responses.  For instance, one type of response that should only be produced when\n   specifically asked for is a \"verbose feedback\" response, like what we\n   get in the old desktop Lurch by double-clicking a traffic light.  This\n   is too much work to create for every step of work, but should be created\n   only when needed.  Thus the LDE could expose a computeVerboseFeedback() function that took\n   the unique ID of an LDE Document structure as input and later sent back\n   a message with the corresponding verbose feedback (in HTML form) as the\n   result.", 
            "title": "Extendability"
        }, 
        {
            "location": "/phase4-dependencies/", 
            "text": "We have designed the work on the Lurch Deductive Engine (LDE) to progress in\nphases.  The idea is that each phase ends with a completed whole that can be\ntested in that state, and that provides more features than the previous\nstate did.  By the time the final phase is complete, the LDE will be a\nrobust and useful product.\n\n\nLDE Design Phase 4: Dependencies\n\n\nContent\n\n\nThis document is not yet complete.  Its content will eventually specify:\n\n\n\n\nSupport dependencies as read-only first-few-children of the document.\n\n\nThey need to be validated only to be sure they don't redeclare one\n   another's stuff.\n\n\nNote that every structure already has an .exports() method, so we just\n   need to implement that structure for the root of the LDE Document, and\n   that will be what a document exports when it is used as a dependency.\n\n\n\n\nGoal\n\n\nRule definitions can be stored in a master document on which others depend,\nand many later documents can all use the same central rule set.\n\n\nStatus\n\n\nThis phase has not yet been implemented.  Once it has been implemented, its\ncontents will be documented in the API Documentation available from the\nnavigation menu at the top of this site.", 
            "title": "Phase 4, Dependencies"
        }, 
        {
            "location": "/phase4-dependencies/#lde-design-phase-4-dependencies", 
            "text": "", 
            "title": "LDE Design Phase 4: Dependencies"
        }, 
        {
            "location": "/phase4-dependencies/#content", 
            "text": "This document is not yet complete.  Its content will eventually specify:   Support dependencies as read-only first-few-children of the document.  They need to be validated only to be sure they don't redeclare one\n   another's stuff.  Note that every structure already has an .exports() method, so we just\n   need to implement that structure for the root of the LDE Document, and\n   that will be what a document exports when it is used as a dependency.", 
            "title": "Content"
        }, 
        {
            "location": "/phase4-dependencies/#goal", 
            "text": "Rule definitions can be stored in a master document on which others depend,\nand many later documents can all use the same central rule set.", 
            "title": "Goal"
        }, 
        {
            "location": "/phase4-dependencies/#status", 
            "text": "This phase has not yet been implemented.  Once it has been implemented, its\ncontents will be documented in the API Documentation available from the\nnavigation menu at the top of this site.", 
            "title": "Status"
        }, 
        {
            "location": "/phase5-background/", 
            "text": "We have designed the work on the Lurch Deductive Engine (LDE) to progress in\nphases.  The idea is that each phase ends with a completed whole that can be\ntested in that state, and that provides more features than the previous\nstate did.  By the time the final phase is complete, the LDE will be a\nrobust and useful product.\n\n\nLDE Design Phase 5: Background Queue\n\n\nContent\n\n\nThis document is not yet complete.  Its content will eventually specify:\n\n\n\n\nAdd a mechanism for queueing tasks to be done later.\n\n\nIt should be smart enough that, whenever task X is enqueued, then any\n   already-enqueued task Y that will need to be redone after X anyway\n   should be removed form the queue, for efficiency.\n\n\nThen rewrite Phases 2 and 3 to use this feature as needed.\n   All later phases should enqueue all nontrivial processing tasks this way.\n\n\n\n\nGoal\n\n\nAll the work done before this operates more efficiently, and the large and\ncomplex deductive engine we plan to build on the foundation we have so far\nwill still be performant.\n\n\nStatus\n\n\nThis phase has not yet been implemented.  Once it has been implemented, its\ncontents will be documented in the API Documentation available from the\nnavigation menu at the top of this site.", 
            "title": "Phase 5, Background Queue"
        }, 
        {
            "location": "/phase5-background/#lde-design-phase-5-background-queue", 
            "text": "", 
            "title": "LDE Design Phase 5: Background Queue"
        }, 
        {
            "location": "/phase5-background/#content", 
            "text": "This document is not yet complete.  Its content will eventually specify:   Add a mechanism for queueing tasks to be done later.  It should be smart enough that, whenever task X is enqueued, then any\n   already-enqueued task Y that will need to be redone after X anyway\n   should be removed form the queue, for efficiency.  Then rewrite Phases 2 and 3 to use this feature as needed.\n   All later phases should enqueue all nontrivial processing tasks this way.", 
            "title": "Content"
        }, 
        {
            "location": "/phase5-background/#goal", 
            "text": "All the work done before this operates more efficiently, and the large and\ncomplex deductive engine we plan to build on the foundation we have so far\nwill still be performant.", 
            "title": "Goal"
        }, 
        {
            "location": "/phase5-background/#status", 
            "text": "This phase has not yet been implemented.  Once it has been implemented, its\ncontents will be documented in the API Documentation available from the\nnavigation menu at the top of this site.", 
            "title": "Status"
        }, 
        {
            "location": "/phase6-strings/", 
            "text": "We have designed the work on the Lurch Deductive Engine (LDE) to progress in\nphases.  The idea is that each phase ends with a completed whole that can be\ntested in that state, and that provides more features than the previous\nstate did.  By the time the final phase is complete, the LDE will be a\nrobust and useful product.\n\n\nLDE Design Phase 6: String Matching\n\n\nContent\n\n\nThis document is not yet complete.  Its content will eventually specify:\n\n\nExtend rules to include string-based matching (like the kind of matching\nCircle-Dot and MIU use)\n\n\nGoal\n\n\nThis enables: toy systems like Circle-Dot and MIU\n\n\nStatus\n\n\nThis phase has not yet been implemented.  Once it has been implemented, its\ncontents will be documented in the API Documentation available from the\nnavigation menu at the top of this site.", 
            "title": "Phase 6, String Matching"
        }, 
        {
            "location": "/phase6-strings/#lde-design-phase-6-string-matching", 
            "text": "", 
            "title": "LDE Design Phase 6: String Matching"
        }, 
        {
            "location": "/phase6-strings/#content", 
            "text": "This document is not yet complete.  Its content will eventually specify:  Extend rules to include string-based matching (like the kind of matching\nCircle-Dot and MIU use)", 
            "title": "Content"
        }, 
        {
            "location": "/phase6-strings/#goal", 
            "text": "This enables: toy systems like Circle-Dot and MIU", 
            "title": "Goal"
        }, 
        {
            "location": "/phase6-strings/#status", 
            "text": "This phase has not yet been implemented.  Once it has been implemented, its\ncontents will be documented in the API Documentation available from the\nnavigation menu at the top of this site.", 
            "title": "Status"
        }, 
        {
            "location": "/phase7-theorems/", 
            "text": "We have designed the work on the Lurch Deductive Engine (LDE) to progress in\nphases.  The idea is that each phase ends with a completed whole that can be\ntested in that state, and that provides more features than the previous\nstate did.  By the time the final phase is complete, the LDE will be a\nrobust and useful product.\n\n\nLDE Design Phase 7: Theorems and Proofs\n\n\nContent\n\n\nThis document is not yet complete.  Its content will eventually specify:\n\n\n\n\nProofs (which are also subproofs)\n\n\nTheorem statements\n\n\nPairing of theorems with proofs\n\n\nHomework problems (which may be the same as a theorem-proof pair!)\n\n\n\n\nGoal\n\n\nThis enables:\n\n\n\n\nProofs\n\n\nHomework assignments\n\n\n\n\nStatus\n\n\nThis phase has not yet been implemented.  Once it has been implemented, its\ncontents will be documented in the API Documentation available from the\nnavigation menu at the top of this site.", 
            "title": "Phase 7, Theorems and Proofs"
        }, 
        {
            "location": "/phase7-theorems/#lde-design-phase-7-theorems-and-proofs", 
            "text": "", 
            "title": "LDE Design Phase 7: Theorems and Proofs"
        }, 
        {
            "location": "/phase7-theorems/#content", 
            "text": "This document is not yet complete.  Its content will eventually specify:   Proofs (which are also subproofs)  Theorem statements  Pairing of theorems with proofs  Homework problems (which may be the same as a theorem-proof pair!)", 
            "title": "Content"
        }, 
        {
            "location": "/phase7-theorems/#goal", 
            "text": "This enables:   Proofs  Homework assignments", 
            "title": "Goal"
        }, 
        {
            "location": "/phase7-theorems/#status", 
            "text": "This phase has not yet been implemented.  Once it has been implemented, its\ncontents will be documented in the API Documentation available from the\nnavigation menu at the top of this site.", 
            "title": "Status"
        }, 
        {
            "location": "/phase8-expressions/", 
            "text": "We have designed the work on the Lurch Deductive Engine (LDE) to progress in\nphases.  The idea is that each phase ends with a completed whole that can be\ntested in that state, and that provides more features than the previous\nstate did.  By the time the final phase is complete, the LDE will be a\nrobust and useful product.\n\n\nLDE Design Phase 8: Expressions\n\n\nContent\n\n\nThis document is not yet complete.  Its content will eventually specify:\n\n\n\n\nExpanded form for non-atomic expressions (function applications,\n   binding, variables, constants, etc.)\n\n\nExtend rules to pattern-based matching (the usual kind of rules we think\n   of in math)\n\n\n\n\nGoal\n\n\nThis enables: propositional logic, but with statements in expanded form only\n\n\nStatus\n\n\nThis phase has not yet been implemented.  Once it has been implemented, its\ncontents will be documented in the API Documentation available from the\nnavigation menu at the top of this site.", 
            "title": "Phase 8, Expression Trees"
        }, 
        {
            "location": "/phase8-expressions/#lde-design-phase-8-expressions", 
            "text": "", 
            "title": "LDE Design Phase 8: Expressions"
        }, 
        {
            "location": "/phase8-expressions/#content", 
            "text": "This document is not yet complete.  Its content will eventually specify:   Expanded form for non-atomic expressions (function applications,\n   binding, variables, constants, etc.)  Extend rules to pattern-based matching (the usual kind of rules we think\n   of in math)", 
            "title": "Content"
        }, 
        {
            "location": "/phase8-expressions/#goal", 
            "text": "This enables: propositional logic, but with statements in expanded form only", 
            "title": "Goal"
        }, 
        {
            "location": "/phase8-expressions/#status", 
            "text": "This phase has not yet been implemented.  Once it has been implemented, its\ncontents will be documented in the API Documentation available from the\nnavigation menu at the top of this site.", 
            "title": "Status"
        }, 
        {
            "location": "/phase9-parsing/", 
            "text": "We have designed the work on the Lurch Deductive Engine (LDE) to progress in\nphases.  The idea is that each phase ends with a completed whole that can be\ntested in that state, and that provides more features than the previous\nstate did.  By the time the final phase is complete, the LDE will be a\nrobust and useful product.\n\n\nLDE Design Phase 9: Parsing\n\n\nContent\n\n\nThis document is not yet complete.  Its content will eventually specify:\n\n\n\n\nRules for defining parsing\n\n\nConstant declarations may be implemented under the hood as special cases\n   of language rules.\n\n\nThis does not mean they must parse into OpenMath symbols.  It is\n  acceptable to parse them into, for example, OpenMath strings, with a\n  special attribute Constant=True, or any equally unique/recognizable\n  expression.\n\n\nAlso, this does not mean that constant declarations must feel to the\n  user like language rule declarations feel.  We can let users think of\n  them and express them as constant declarations, but under the hood it\n  may be implemented as if it had been a language rule.\n\n\n\n\n\n\n\n\nGoal\n\n\nThis enables: propositional logic in its usual notation, and other related\nsimple systems\n\n\nStatus\n\n\nThis phase has not yet been implemented.  Once it has been implemented, its\ncontents will be documented in the API Documentation available from the\nnavigation menu at the top of this site.", 
            "title": "Phase 9, Parsing Rules"
        }, 
        {
            "location": "/phase9-parsing/#lde-design-phase-9-parsing", 
            "text": "", 
            "title": "LDE Design Phase 9: Parsing"
        }, 
        {
            "location": "/phase9-parsing/#content", 
            "text": "This document is not yet complete.  Its content will eventually specify:   Rules for defining parsing  Constant declarations may be implemented under the hood as special cases\n   of language rules.  This does not mean they must parse into OpenMath symbols.  It is\n  acceptable to parse them into, for example, OpenMath strings, with a\n  special attribute Constant=True, or any equally unique/recognizable\n  expression.  Also, this does not mean that constant declarations must feel to the\n  user like language rule declarations feel.  We can let users think of\n  them and express them as constant declarations, but under the hood it\n  may be implemented as if it had been a language rule.", 
            "title": "Content"
        }, 
        {
            "location": "/phase9-parsing/#goal", 
            "text": "This enables: propositional logic in its usual notation, and other related\nsimple systems", 
            "title": "Goal"
        }, 
        {
            "location": "/phase9-parsing/#status", 
            "text": "This phase has not yet been implemented.  Once it has been implemented, its\ncontents will be documented in the API Documentation available from the\nnavigation menu at the top of this site.", 
            "title": "Status"
        }, 
        {
            "location": "/phase10-declarations/", 
            "text": "We have designed the work on the Lurch Deductive Engine (LDE) to progress in\nphases.  The idea is that each phase ends with a completed whole that can be\ntested in that state, and that provides more features than the previous\nstate did.  By the time the final phase is complete, the LDE will be a\nrobust and useful product.\n\n\nLDE Design Phase 10: Declarations\n\n\nContent\n\n\nThis document is not yet complete.  Its content will eventually specify:\n\n\n\n\nVariable declarations (which may be a special type of expression, or may\n   be a special type of subproof--i.e., do we mark a variable as a\n   declaration, or do we mark a subproof as a variable declaration one, and\n   then the variable at the start of it is declared?)\n\n\nExamples (structures in which you declare all manner of stuff that\n   doesn't bleed out)\n\n\n\n\nGoal\n\n\nThis enables: predicate logic in standard math notation, and many other math\ntopics\n\n\nStatus\n\n\nThis phase has not yet been implemented.  Once it has been implemented, its\ncontents will be documented in the API Documentation available from the\nnavigation menu at the top of this site.", 
            "title": "Phase 10, Declarations"
        }, 
        {
            "location": "/phase10-declarations/#lde-design-phase-10-declarations", 
            "text": "", 
            "title": "LDE Design Phase 10: Declarations"
        }, 
        {
            "location": "/phase10-declarations/#content", 
            "text": "This document is not yet complete.  Its content will eventually specify:   Variable declarations (which may be a special type of expression, or may\n   be a special type of subproof--i.e., do we mark a variable as a\n   declaration, or do we mark a subproof as a variable declaration one, and\n   then the variable at the start of it is declared?)  Examples (structures in which you declare all manner of stuff that\n   doesn't bleed out)", 
            "title": "Content"
        }, 
        {
            "location": "/phase10-declarations/#goal", 
            "text": "This enables: predicate logic in standard math notation, and many other math\ntopics", 
            "title": "Goal"
        }, 
        {
            "location": "/phase10-declarations/#status", 
            "text": "This phase has not yet been implemented.  Once it has been implemented, its\ncontents will be documented in the API Documentation available from the\nnavigation menu at the top of this site.", 
            "title": "Status"
        }, 
        {
            "location": "/phase11-features/", 
            "text": "We have designed the work on the Lurch Deductive Engine (LDE) to progress in\nphases.  The idea is that each phase ends with a completed whole that can be\ntested in that state, and that provides more features than the previous\nstate did.  By the time the final phase is complete, the LDE will be a\nrobust and useful product.\n\n\nLDE Design Phase 11: Features\n\n\nContent\n\n\nThis document is not yet complete.  Its content will eventually specify:\n\n\nAdd features to anything built so far (like multiple conclusions from a\nrule, or automatic premise finding, or automatic premise ordering, or the\nability to specify metavariable instantiations, or any of 1000 other\nfeatures we'd like to add)\n\n\nGoal\n\n\nThis enables everything else\n\n\nStatus\n\n\nThis phase has not yet been implemented.  Once it has been implemented, its\ncontents will be documented in the API Documentation available from the\nnavigation menu at the top of this site.", 
            "title": "Phase 11, Bonus Features"
        }, 
        {
            "location": "/phase11-features/#lde-design-phase-11-features", 
            "text": "", 
            "title": "LDE Design Phase 11: Features"
        }, 
        {
            "location": "/phase11-features/#content", 
            "text": "This document is not yet complete.  Its content will eventually specify:  Add features to anything built so far (like multiple conclusions from a\nrule, or automatic premise finding, or automatic premise ordering, or the\nability to specify metavariable instantiations, or any of 1000 other\nfeatures we'd like to add)", 
            "title": "Content"
        }, 
        {
            "location": "/phase11-features/#goal", 
            "text": "This enables everything else", 
            "title": "Goal"
        }, 
        {
            "location": "/phase11-features/#status", 
            "text": "This phase has not yet been implemented.  Once it has been implemented, its\ncontents will be documented in the API Documentation available from the\nnavigation menu at the top of this site.", 
            "title": "Status"
        }, 
        {
            "location": "/enhancements/", 
            "text": "Enhancements for Later\n\n\nThis page lists helpful enhancements to work already completed, but which\nwere not essential enough to have been included in the work done so far.  We\nlist them here so as not to lose track of important improvements we might\nmake later, and we leave empty check boxes next to them so that we can later\nmark them complete as they are implemented.\n\n\n\n\n Make the \nlabels()\n function more efficient as follows.\n\n\nWhenever it is computed, cache the value in an internal field.\n\n\nThe next time \nlabels()\n is called, use the cached value if it exists.\n\n\nWhenever you call \nwasChanged()\n, be sure to clear the cached value.\n\n\n\n\n\n\n Make the \nwhatCitesMe()\n function more efficient by making it loop\n   manually through all the things in scope, tracking when anything in its\n   scope eclipses it by being labeled with one or more of its labels.  If at\n   any point it has no more labels left in force, stop iterating.  This is a\n   minor performance gain, because it will be rare that a structure is fully\n   eclipsed by other structures with the same name.", 
            "title": "Enhancements for Later"
        }, 
        {
            "location": "/enhancements/#enhancements-for-later", 
            "text": "This page lists helpful enhancements to work already completed, but which\nwere not essential enough to have been included in the work done so far.  We\nlist them here so as not to lose track of important improvements we might\nmake later, and we leave empty check boxes next to them so that we can later\nmark them complete as they are implemented.    Make the  labels()  function more efficient as follows.  Whenever it is computed, cache the value in an internal field.  The next time  labels()  is called, use the cached value if it exists.  Whenever you call  wasChanged() , be sure to clear the cached value.     Make the  whatCitesMe()  function more efficient by making it loop\n   manually through all the things in scope, tracking when anything in its\n   scope eclipses it by being labeled with one or more of its labels.  If at\n   any point it has no more labels left in force, stop iterating.  This is a\n   minor performance gain, because it will be rare that a structure is fully\n   eclipsed by other structures with the same name.", 
            "title": "Enhancements for Later"
        }, 
        {
            "location": "/ideas/", 
            "text": "LDE Design Idea Archive\n\n\nThis document records incomplete ideas the Lurch team is keeping in mind\nfor integration into later design plans.\n\n\n\n\nWe have considered a UI with buttons with mathematical names on them,\n   such as Justify (which would let you choose a reason and it would insert\n   it), Cite (which would let you click any premise and it would make the\n   arrow), a toolbar of all math words.\n\n\nWe have tested a Suggestions feature, and could really use it widely:\n\n\nWhen the cursor is near something the software could recognize as a\n  statement or a reason, it gives a faint shadow over it of what it\n  thinks you're saying.\n\n\nA single keystroke confirms, and if you don't use that keystroke, the\n  shadowy suggestion is never actually realized in the document.\n\n\nExample usage:\n\n\nType, then hit \nCtrl+Enter\n to approve an interpretation of what\n  you said as a statement.\n\n\nA visual indicator of some kind shows that the bubble was formed,\n  but since your cursor is after it, the bubble-forming animation\n  fades.\n\n\nKeep typing, then hit \nCtrl+Enter\n to approve an interpretation of\n  what you said as a reason.\n\n\nSame visual indicator process.\n\n\nImmediately a suggested connection of the reason to the statement\n  appears, and you hit \nCtrl+Enter\n again to connect them.\n\n\nSame visual indicator process.\n\n\nStart typing your next statement, and repeat from step 1.\n\n\n\n\n\n\nWhenever your cursor is in a statement accessible to the most recent\n  justification you formed, a suggested premise citation arrow could\n  appear; \nCtrl+Enter\n to confirm.\n\n\n\n\n\n\nMathQuill (and, one day, MathJax, if we choose to add it) are UX sugar\n   that sits above the document, and can be converted to text as part of\n   the UI's processing of HTML into Structures.\n\n\nA UI idea from long ago recorded here for safe keeping:\n\n\nConsider all situations in which it\u2019s possible to write a small JS\n  function that can easily take in a string of text and split it into\n  an array of substrings, like \n\"Fred is a fish\"\n to\n  \n[\"Fred is\", \"a\", \"fish\"]\n, such that the array alternates between\n  meaningful stuff and non-meaningful stuff. Then we have two things we\n  can do with such a function.\n\n\nFirst, the translator can obviously use that to trivially lift the\n  meaningful stuff out.\n\n\nSecond, the UX can also use it to \nhighlight\n \nwhile the user is\n  typing in a group\n which parts of the group\u2019s content the app is\n  paying attention to, and which parts it\u2019s ignoring. Imagine typing\n  \n[Fred is a fish]\n and the app is gently highlighting everything\n  except the 'a' or typing\n  \n[Fred, who we all love, is a very nice fish]\n\n  and the app highlights like so:\n  [\nFRED\n, who we all love, \nIS\n a very nice \nFISH\n].\n  Such highlighting would be in the overlay where the bubble is drawn,\n  and shown only when the cursor is in there.\n\n\nOne specific subclass of this idea is when we require rigid formal\n  syntax, like line-numbered proofs with\n  \nstatement[whitespace]reason[whitespace]premise,...", 
            "title": "Ideas Archive"
        }, 
        {
            "location": "/ideas/#lde-design-idea-archive", 
            "text": "This document records incomplete ideas the Lurch team is keeping in mind\nfor integration into later design plans.   We have considered a UI with buttons with mathematical names on them,\n   such as Justify (which would let you choose a reason and it would insert\n   it), Cite (which would let you click any premise and it would make the\n   arrow), a toolbar of all math words.  We have tested a Suggestions feature, and could really use it widely:  When the cursor is near something the software could recognize as a\n  statement or a reason, it gives a faint shadow over it of what it\n  thinks you're saying.  A single keystroke confirms, and if you don't use that keystroke, the\n  shadowy suggestion is never actually realized in the document.  Example usage:  Type, then hit  Ctrl+Enter  to approve an interpretation of what\n  you said as a statement.  A visual indicator of some kind shows that the bubble was formed,\n  but since your cursor is after it, the bubble-forming animation\n  fades.  Keep typing, then hit  Ctrl+Enter  to approve an interpretation of\n  what you said as a reason.  Same visual indicator process.  Immediately a suggested connection of the reason to the statement\n  appears, and you hit  Ctrl+Enter  again to connect them.  Same visual indicator process.  Start typing your next statement, and repeat from step 1.    Whenever your cursor is in a statement accessible to the most recent\n  justification you formed, a suggested premise citation arrow could\n  appear;  Ctrl+Enter  to confirm.    MathQuill (and, one day, MathJax, if we choose to add it) are UX sugar\n   that sits above the document, and can be converted to text as part of\n   the UI's processing of HTML into Structures.  A UI idea from long ago recorded here for safe keeping:  Consider all situations in which it\u2019s possible to write a small JS\n  function that can easily take in a string of text and split it into\n  an array of substrings, like  \"Fred is a fish\"  to\n   [\"Fred is\", \"a\", \"fish\"] , such that the array alternates between\n  meaningful stuff and non-meaningful stuff. Then we have two things we\n  can do with such a function.  First, the translator can obviously use that to trivially lift the\n  meaningful stuff out.  Second, the UX can also use it to  highlight   while the user is\n  typing in a group  which parts of the group\u2019s content the app is\n  paying attention to, and which parts it\u2019s ignoring. Imagine typing\n   [Fred is a fish]  and the app is gently highlighting everything\n  except the 'a' or typing\n   [Fred, who we all love, is a very nice fish] \n  and the app highlights like so:\n  [ FRED , who we all love,  IS  a very nice  FISH ].\n  Such highlighting would be in the overlay where the bubble is drawn,\n  and shown only when the cursor is in there.  One specific subclass of this idea is when we require rigid formal\n  syntax, like line-numbered proofs with\n   statement[whitespace]reason[whitespace]premise,...", 
            "title": "LDE Design Idea Archive"
        }, 
        {
            "location": "/api-overview/", 
            "text": "API Documentation Overview\n\n\nDesign Plans vs. API Documentation\n\n\nAt the top of this site, notice the two navigation menus entitled \"Design\nPlans\" and \"API Documentation.\"  The difference between them is this:\n\n\n\n\nDesign Plans\n lists concepts that have not yet been implemented and\n   documented.  Consequently, the concepts are usually not described in full\n   detail, but just the best detail available in the planning phase.\n   It answers the question, \"What do we plan to build?\"\n\n\nAPI Documentation\n lists concepts that have been implemented, and for\n   which the developers have therefore been able to document their work.\n   Having the benefit of hindsight, this is therefore more detailed, and\n   often even contains links directly into the source code.\n   It answers the question, \"What did we build?\" and is the official\n   documentation for the modules.\n\n\n\n\nAny page in the Design Plans that has been complete has had most of its\ncontent removed, because it has been superceded by the corresponding API\ndocumentation.  What remains is just a record of what was planne for that\nphase, with links to the corresponding API Documentation.\n\n\nDeveloper Workflow\n\n\nDevelopers designing and/or implementing concepts should therefore progress\nthose concepts through a lifecycle like so:\n\n\n\n\nDescribe the concept in one of the Design Plans page.  Provide as much\n    detail as you can, knowing of course that full details is impossible to\n    provide before the work has been done.\n\n\nAs you implement and test the concept, update those design documents\n    with whatever new information you create or learn as part of the work,\n    thus making them more precise.\n\n\nOnce the concept is fully implemented and tested, document the work in\n    an existing or new page in the API Documentation section.  This may\n    involve copying and pasting some of the content from the design plan,\n    provided that it still applies.  It will probably also involve adding\n    significant detail about the particulars of the implementation.\n\n\nReplace the original (less detailed) documentation in the design plans\n    with a brief description of the concept, followed by a link to the\n    corresponding part of the API Documentation for full details.\n\n\n\n\nFor the Reader\n\n\nReaders of this documentation will therefore be able to see how much has\nbeen implemented by perusing the Design Plans pages.  Those that are brief\noverviews of concepts with links to API Documentation have been implemented.\nThose that are plans for future work, with no links to any API\nDocumentation, have not yet been implemented.", 
            "title": "Overview"
        }, 
        {
            "location": "/api-overview/#api-documentation-overview", 
            "text": "", 
            "title": "API Documentation Overview"
        }, 
        {
            "location": "/api-overview/#design-plans-vs-api-documentation", 
            "text": "At the top of this site, notice the two navigation menus entitled \"Design\nPlans\" and \"API Documentation.\"  The difference between them is this:   Design Plans  lists concepts that have not yet been implemented and\n   documented.  Consequently, the concepts are usually not described in full\n   detail, but just the best detail available in the planning phase.\n   It answers the question, \"What do we plan to build?\"  API Documentation  lists concepts that have been implemented, and for\n   which the developers have therefore been able to document their work.\n   Having the benefit of hindsight, this is therefore more detailed, and\n   often even contains links directly into the source code.\n   It answers the question, \"What did we build?\" and is the official\n   documentation for the modules.   Any page in the Design Plans that has been complete has had most of its\ncontent removed, because it has been superceded by the corresponding API\ndocumentation.  What remains is just a record of what was planne for that\nphase, with links to the corresponding API Documentation.", 
            "title": "Design Plans vs. API Documentation"
        }, 
        {
            "location": "/api-overview/#developer-workflow", 
            "text": "Developers designing and/or implementing concepts should therefore progress\nthose concepts through a lifecycle like so:   Describe the concept in one of the Design Plans page.  Provide as much\n    detail as you can, knowing of course that full details is impossible to\n    provide before the work has been done.  As you implement and test the concept, update those design documents\n    with whatever new information you create or learn as part of the work,\n    thus making them more precise.  Once the concept is fully implemented and tested, document the work in\n    an existing or new page in the API Documentation section.  This may\n    involve copying and pasting some of the content from the design plan,\n    provided that it still applies.  It will probably also involve adding\n    significant detail about the particulars of the implementation.  Replace the original (less detailed) documentation in the design plans\n    with a brief description of the concept, followed by a link to the\n    corresponding part of the API Documentation for full details.", 
            "title": "Developer Workflow"
        }, 
        {
            "location": "/api-overview/#for-the-reader", 
            "text": "Readers of this documentation will therefore be able to see how much has\nbeen implemented by perusing the Design Plans pages.  Those that are brief\noverviews of concepts with links to API Documentation have been implemented.\nThose that are plans for future work, with no links to any API\nDocumentation, have not yet been implemented.", 
            "title": "For the Reader"
        }, 
        {
            "location": "/api-structures/", 
            "text": "API Documentation for the \nStructure\n Class\n\n\nSource Code\n\n\n\n\nThe \nStructure\n class\n\n\nUnit tests of the \nStructure\n class\n\n\n\n\nPurpose\n\n\nThe Lurch Deductive Engine (LDE, \ndocumented here\n) maintains a\ndocument called hte LDE Document, which is a hierarchy (or tree).  The nodes\nin that tree are instances of this class (\nStructure\n) or one of its\nsubclasses.\n\n\nWe build into this base class all the functionality that must be present at\nevery point in that hierarchy, and leave to subclasses that functionality\nthat makes sense only for specific types of structures.  For instance, this\nclass contains no functionality to support rules of inference, because they\nare one specific type of structure, so their functionality will be\nimplemented in a subclass for that purpose.\n\n\nConstructing and Serialization\n\n\nThere is one constructor for the class\n(\nsee source code\n):\n\n\nStructure(child1,child2,...)\n creates a new instance, with the given list\nof children, each of which must be a \nStructure\n instance (or it will be\nignored).  All such children are removed from any old parent they had before\nbeing inserted into this newly created one.\n\n\nInstances can be converted to and from JSON, for saving to a file, storing\npermanently anywhere, or transmitting across threads or network connections.\nTo ensure that deserialization correctly reconstructs instances of the right\nsubclass of \nStructure\n, each subclass must be registered.  To do so, we\nprovide the \naddSubclass\n function.  Use it like so.\n\n\nJavaScript:\n\n\n    MySubclass = function ( /* ... */ ) { /* ... */ };\n    // ...\n    MySubclass.prototype.className = Structure.addSubclass( 'MySubclass', MySubclass );\n\n\n\n\nCoffeeScript, somewhere inside the class definition:\n\n\n    class MySubclass extends Structure\n        # ...\n        className : Structure.addSubclass 'MySubclass', MySubclass\n        # ...\n\n\n\n\nThen one can serialize and deserialize any hierarchy containing \nStructure\n\ninstances, as well as instances of its subclasses, using the member function\n\nsomeInstance.toJSON()\n (which obviously yields a JSON structure) or the\nclass function \nStructure.fromJSON(data)\n, which accepts JSON data created\nfrom the first function.\n\n\nSerializing a structure preserves its class, its external and computed\nattributes (\ndocumented below\n), and\nthe hierarchy for which it is the root.  Unique IDs\n(\ndocumented below\n) are not preserved.  Deserializing does not\nassign new unique IDs, but the \nsetup()\n function documented under\n\nthe Unique IDs section, below\n can be used to assign new\nunique IDs to the nodes in a just-deserialized hierarchy.\n\n\nStructure hierarchies\n\n\nTo navigate or alter a hierarchy of \nStructure\n instances, use the\nfollowing member functions present in each instance.\n\n\n\n\ninstance.parent()\n yields the parent structure, or \nnull\n if there is\n   no parent (i.e., the instance is the root of a hierarchy)\n\n\ninstance.children()\n yields an array containing the children structures,\n   in order, or an empty array if there are none\n\n\ninstance.indexInParent()\n yields the index of the child in its parent's\n   ordered list of children, or unddefined if the instance has no parent\n\n\ninstance.previousSibling()\n and \ninstance.nextSibling()\n yield the\n   adjacent structure in the parent's child list, forward or backward, as\n   expected, or undefined if there is no such sibling\n\n\ninstance.removeFromParent()\n drops the instance from it's parent's list\n   of children (thereby decreasing the length of that child list by 1) and\n   thus making \ninstance.parent()\n null\n\n\ninstance.removeChild(index)\n is a convenience equivalent to\n   \ninstance.children()[index].removeFromParent()\n\n\ninstance.insertChild(child,index)\n expects a structure instance as the\n   first argument and an index into the children list as the second.  It\n   inserts the new child at that index, thus increasing the number of\n   children by 1.  You may use an index equal to the length of the child\n   list to append.  The child is removed from its previous parent, if any,\n   before being inserted here.\n\n\ninstance.replaceWith(other)\n expects another structure instance as its\n   argument.  It removes \ninstance\n from its parent, if there is one, and\n   then inserts \nother\n at the same index in the parent, thus replacing\n   \ninstance\n.  This has no effect if \ninstance\n has no parent.  It is\n   equivalent to successive calls to \nremoveFromParent()\n and\n   \ninsertChild()\n at the instance and its parent, respectively.\n\n\ninstance.copy()\n makes a deep copy of the instance, including all nodes\n   below it in the hierarchy, but not copying their unique IDs (lest they\n   become not unique)\n\n\n\n\nThe order of nodes in the hierarchy is often important.  We have one simple\norder relation on the nodes in the hierarchy, and one more complex.  The\nsimplest is just whether node A is \"earlier than\" node B, in the order\ninduced by an in-order tree traversal (that is, the order in which the open\nparentheses would appear if the tree were written as a LISP expression).\nThis relation can be tested with \ninstance.isEarlierThan(other)\n.\n\n\nThe more complex order relation is accessibility, which we do not define\nhere, because it is already defined \nin the source code\ndocumentation\n.\nThat relation is implemented with the following member functions available\nin all instances of the class.\n\n\n\n\nA.isAccessibleTo(B)\n implements the relation as defined at the link\n   given above.\n\n\nA.isInTheScopeOf(B)\n is equivalent to \nB.isAccessibleTo(A)\n.\n\n\nA.iteratorOverAccessibles()\n yields an \"iterator\" object, which is an\n   object that can produce the list of nodes accessible to \nA\n by repeated\n   calls to the \nnext()\n member of the object.  Consider the following\n   JavaScript code that would use such an iterator.\n\n\n\n\n    var iterator = A.iteratorOverAccessibles();\n    var accessible;\n    while ( accessible = iterator.next() ) {\n        console.log( 'The next accessible structure is:',\n            accessible.toJSON() );\n    }\n\n\n\n\nNodes are produced by the iterator in reverse order (under the\n\nisEarlierThan\n relation) starting from the first accessible node before\n\nA\n.  When the \nnext()\n function yields null for the first time, the end of\nthe list has been reached.  (The \nnext()\n function will yield null forever\nthereafter.)\n\n\nIterators are more efficient than producing the entire list and returning\nit, because the client may be seeking just one particular node in the list,\nand thus producing the entire list so that the client can search just a\nsmall part of it could be wasteful.\n\n\nThere is an analogous function for scopes.\n\n\n\n\nA.iteratorOverScope()\n functions like \nA.iteratorOverAccessibles()\n, but\n   walks forwards through the structure, including precisely those nodes for\n   which \nB.isInTheScopeOf(A)\n holds true.\n\n\n\n\nThere are then four functions that use these iterators under the hood.\nClients will most likely wish to use these rather than have direct access\nto the iterators.\n\n\n\n\nA.firstAccessible(P)\n expects \nP\n to be a one-place predicate (that is,\n   a JavaScript function that can be evaluated on a single argument, and\n   yields true or false in each case) and yields the first item on the\n   \"accessibles\" list (as given by \nA.iteratorOverAccessibles()\n) for which\n   \nP\n yields true.  It returns undefined if there is no such thing.\n\n\nA.firstInScope(P)\n expects \nP\n to be a one-place predicate, as just\n   defined, and behaves just like \nfirstAccessible()\n, except it walks\n   through \nA.iteratorOverScope()\n instead.\n\n\nA.allAccessibles(P)\n expects \nP\n as in the previous two functions, and\n   yields all nodes accessible to \nA\n that satisfy \nP\n, in the same order\n   they would be reported by \niteratorOverAccessibles()\n.\n\n\nA.allInScope(P)\n expects \nP\n as in the previous two functions, and\n   yields all nodes in the scope of \nA\n that satisfy \nP\n, in the same order\n   they would be reported by \niteratorOverScope()\n.\n\n\n\n\nStructure attributes and connections\n\n\nAttributes in general\n\n\nStructures have two types of attributes, computed and external.  The\ndistinction is documented in the source code,\n\nhere\n and\n\nhere\n.\n\n\nThe following functions available in each instance of the structure class\nsupport external and computed attributes.\n\n\n\n\ninstance.getComputedAttribute(key)\n and\n   \ninstance.getExternalAttribute(key)\n look up computed or external\n   attributes by a given string \nkey\n.\n\n\ninstance.setComputedAttribute(key,value)\n and\n   \ninstance.setExternalAttribute(key,value)\n store computed or external\n   attributes under a given string \nkey\n with value \nvalue\n, which should be\n   a JSON structure (or atomic data).  No check is made to verify that the\n   value is of this type, but errors will transpire later if this condition\n   is not satisfied (specifically, serialization errors).\n\n\ninstance.clearComputedAttributes(key1,key2,...)\n and\n   \ninstance.clearExternalAttributes(key1,key2,...)\n remove the key-value\n   pairs of computed or external attributes associated with any of the keys\n   passed as parameters.  It is acceptable to pass any number of keys,\n   including just one.  If zero are passed, \nall\n key-value pairs are\n   removed.\n\n\ninstance.attr(object)\n adds all attributes of the given object as\n   external attributes to the instance, and returns the instance itself.\n   This is useful when constructing hierarchies, as follows.\n\n\n\n\n    var A = new Structure(\n        ( new Structure() ).attr( { name : 'example structure' } ),\n        ( new Structure() ).attr( { color : '#99ff00' } )\n    );\n\n\n\n\n\n\ninstance.compute(arguments)\n is a useful shortcut for storing computed\n   attributes.  We do not redocument its details here; see the documentation\n   in the source code at the end of\n   \nthis section\n.\n\n\n\n\nConnections as a type of attribute\n\n\nWithin a structure's external attributes are two key-value pairs that should\nnot be used for any other purpose, those with keys \nconnectionsOut\n and\n\nconnectionsIn\n.  These store data about connections between pairs of\nstructures in the same heirarchy.  The data is stored by structure IDs, so\nmaking connections assumes that structures each have a unique ID, as\ndocumented \nbelow\n.\n\n\nYou can query the connections among structures with these functions:\n\n\n\n\nsource.allConnectionsOut(type)\n returns a list of all destinations to\n   which the source is connected by one or more connections of the given\n   type.  Each destination appears on the list a number of times equal to\n   the number of connections of the given type from the source to that\n   destination.\n\n\ndestination.allConnectionsIn(type)\n functions analogously to the\n   previous, but for connections into a destination, rather than out from a\n   source.\n\n\nsource.allConnectionsOut()\n returns a list of destination-type pairs,\n   all connections that go out from the given source structure.\n\n\ndestination.allConnectionsIn()\n functions analogously to the previous,\n   but for connections into a destination, rather than out from a source.\n\n\ndestination.properties()\n looks at the set of source structures that\n   connect to the destination via arrows, and forms a dictionary of\n   key-value pairs, the \"properties\" of the destination.  The key will be\n   the type of the connection and the value will be the array of sources\n   that connected to the destination with that connection type.\n\n\n\n\nTo create or destroy connections, use these functions:\n\n\n\n\nsource.connectTo(destination,type)\n, where \nsource\n and \ndestination\n\n   are \nStructure\n instances and \ntype\n is a string containing the type of\n   connection, creates a new connection.  There can be multiple connections\n   between the same two structures, even of the same type.  Returns true if\n   the connection was formed, false if some error prevented it (such as the\n   destination not being a structure, or not having an ID, or the source\n   not having an ID).\n\n\nsource.disconnectFrom(destination,type)\n undoes the previous operation.\n   Because there may be multiple connections between the source and\n   destination of the same type, this simply decreases that number by one.\n   Returns true on success or false on failure (for example, if there were\n   no connection to delete).\n\n\n\n\nIf the \nconnectionsOut\n and \nconnectionsIn\n data is directly manipulated by\nthe client (not recommended), then you can call \nroot.fillOutConnections()\n\nto ensure that the connection data stored in every source matches that\nstored in the corresponding destinations, and vice versa.\n\n\nOther attribute conventions\n\n\nText:\n  Some structures contain plain text.  The convention is to store\n\nthese in the external attribute with key \"text.\"  For convenience, there is\n\na \ntext()\n member function in the structure class that looks up this\n*attribute's value.\n\n\nReferences:\n  Some structures serve as references to other structures.\n\nThey are marked as references with the external attribute \"reference.\"  For\n\nconvenience, there is a \nisAReference()\n member function in the structure\n\nclass that looks up whether this attribute is present, and thus the\n\nstructure is functioning as a reference.\n\n\nLabels:\n  Get a list of all text values used as labels for a structure by\ncalling its member function \nlabels()\n.  There are several ways that a\nstructure can be labeled, all documented\n\nin the source code\n.  All labels are strings.\n\n\nCheck whether a string is on that list with the member function\n\nhasLabel(label)\n.\n\n\nReasons and premises:\n  You can get a list of all reasons or premises\nattached to a structure with the member functions \nreasons()\n and\n\npremises()\n.  These may be structures or the names by which structures\naccessible to this one are labeled.  There are several ways that a structure\ncan have a reason or premise attached, all documented\n\nin the source code\n.\n\n\nCitations:\n  Given a string and a structure \nS\n, you can look up the\nnearest accessible (to \nS\n) structure that has that string as a label with\n\nS.lookup(label)\n.  We say that one structure cites another if it has that\nother as a reason or premise; you can query this binary relation with\n\nstructure.cites(other)\n, and get a list of everything that cites a given\nstructure with \nstructure.whatCitesMe()\n.\n\n\nUnique IDs\n\n\nThe \nStructure\n class maintains a mapping from nonnegative integer IDs to\ninstances of the class.  A class, upon construction, doesn't get assigned a\nunique ID by default, but you can request one at any time.\n\n\nHere are the relevant functions:\n\n\n\n\ninstance.ID\n contains the instance's ID, if it has one, or undefined if\n   not\n\n\ninstance.getID()\n asks the class to allocate a new, unique ID to the\n   instance.  It does nothing if the instance already had an ID.\n\n\ninstance.releaseID()\n deletes the ID from the instance and lets the\n   class know that the ID is no longer in use, so that it may be assigned to\n   another instance later\n\n\nStructure.instanceWithID(id)\n takes a nonnegative integer ID and yields\n   the instance with that ID, if there is one, or null or undefined if there\n   is none.\n\n\n\n\nIf you have a structure hierarchy in which you wish all nodes to have a\nunique ID installed, call \nsetup()\n on the root, and it will recursively\ncall \ngetID()\n in each instance.  It will also call \nfillOutConnections()\n.", 
            "title": "Structures"
        }, 
        {
            "location": "/api-structures/#api-documentation-for-the-structure-class", 
            "text": "", 
            "title": "API Documentation for the Structure Class"
        }, 
        {
            "location": "/api-structures/#source-code", 
            "text": "The  Structure  class  Unit tests of the  Structure  class", 
            "title": "Source Code"
        }, 
        {
            "location": "/api-structures/#purpose", 
            "text": "The Lurch Deductive Engine (LDE,  documented here ) maintains a\ndocument called hte LDE Document, which is a hierarchy (or tree).  The nodes\nin that tree are instances of this class ( Structure ) or one of its\nsubclasses.  We build into this base class all the functionality that must be present at\nevery point in that hierarchy, and leave to subclasses that functionality\nthat makes sense only for specific types of structures.  For instance, this\nclass contains no functionality to support rules of inference, because they\nare one specific type of structure, so their functionality will be\nimplemented in a subclass for that purpose.", 
            "title": "Purpose"
        }, 
        {
            "location": "/api-structures/#constructing-and-serialization", 
            "text": "There is one constructor for the class\n( see source code ):  Structure(child1,child2,...)  creates a new instance, with the given list\nof children, each of which must be a  Structure  instance (or it will be\nignored).  All such children are removed from any old parent they had before\nbeing inserted into this newly created one.  Instances can be converted to and from JSON, for saving to a file, storing\npermanently anywhere, or transmitting across threads or network connections.\nTo ensure that deserialization correctly reconstructs instances of the right\nsubclass of  Structure , each subclass must be registered.  To do so, we\nprovide the  addSubclass  function.  Use it like so.  JavaScript:      MySubclass = function ( /* ... */ ) { /* ... */ };\n    // ...\n    MySubclass.prototype.className = Structure.addSubclass( 'MySubclass', MySubclass );  CoffeeScript, somewhere inside the class definition:      class MySubclass extends Structure\n        # ...\n        className : Structure.addSubclass 'MySubclass', MySubclass\n        # ...  Then one can serialize and deserialize any hierarchy containing  Structure \ninstances, as well as instances of its subclasses, using the member function someInstance.toJSON()  (which obviously yields a JSON structure) or the\nclass function  Structure.fromJSON(data) , which accepts JSON data created\nfrom the first function.  Serializing a structure preserves its class, its external and computed\nattributes ( documented below ), and\nthe hierarchy for which it is the root.  Unique IDs\n( documented below ) are not preserved.  Deserializing does not\nassign new unique IDs, but the  setup()  function documented under the Unique IDs section, below  can be used to assign new\nunique IDs to the nodes in a just-deserialized hierarchy.", 
            "title": "Constructing and Serialization"
        }, 
        {
            "location": "/api-structures/#structure-hierarchies", 
            "text": "To navigate or alter a hierarchy of  Structure  instances, use the\nfollowing member functions present in each instance.   instance.parent()  yields the parent structure, or  null  if there is\n   no parent (i.e., the instance is the root of a hierarchy)  instance.children()  yields an array containing the children structures,\n   in order, or an empty array if there are none  instance.indexInParent()  yields the index of the child in its parent's\n   ordered list of children, or unddefined if the instance has no parent  instance.previousSibling()  and  instance.nextSibling()  yield the\n   adjacent structure in the parent's child list, forward or backward, as\n   expected, or undefined if there is no such sibling  instance.removeFromParent()  drops the instance from it's parent's list\n   of children (thereby decreasing the length of that child list by 1) and\n   thus making  instance.parent()  null  instance.removeChild(index)  is a convenience equivalent to\n    instance.children()[index].removeFromParent()  instance.insertChild(child,index)  expects a structure instance as the\n   first argument and an index into the children list as the second.  It\n   inserts the new child at that index, thus increasing the number of\n   children by 1.  You may use an index equal to the length of the child\n   list to append.  The child is removed from its previous parent, if any,\n   before being inserted here.  instance.replaceWith(other)  expects another structure instance as its\n   argument.  It removes  instance  from its parent, if there is one, and\n   then inserts  other  at the same index in the parent, thus replacing\n    instance .  This has no effect if  instance  has no parent.  It is\n   equivalent to successive calls to  removeFromParent()  and\n    insertChild()  at the instance and its parent, respectively.  instance.copy()  makes a deep copy of the instance, including all nodes\n   below it in the hierarchy, but not copying their unique IDs (lest they\n   become not unique)   The order of nodes in the hierarchy is often important.  We have one simple\norder relation on the nodes in the hierarchy, and one more complex.  The\nsimplest is just whether node A is \"earlier than\" node B, in the order\ninduced by an in-order tree traversal (that is, the order in which the open\nparentheses would appear if the tree were written as a LISP expression).\nThis relation can be tested with  instance.isEarlierThan(other) .  The more complex order relation is accessibility, which we do not define\nhere, because it is already defined  in the source code\ndocumentation .\nThat relation is implemented with the following member functions available\nin all instances of the class.   A.isAccessibleTo(B)  implements the relation as defined at the link\n   given above.  A.isInTheScopeOf(B)  is equivalent to  B.isAccessibleTo(A) .  A.iteratorOverAccessibles()  yields an \"iterator\" object, which is an\n   object that can produce the list of nodes accessible to  A  by repeated\n   calls to the  next()  member of the object.  Consider the following\n   JavaScript code that would use such an iterator.       var iterator = A.iteratorOverAccessibles();\n    var accessible;\n    while ( accessible = iterator.next() ) {\n        console.log( 'The next accessible structure is:',\n            accessible.toJSON() );\n    }  Nodes are produced by the iterator in reverse order (under the isEarlierThan  relation) starting from the first accessible node before A .  When the  next()  function yields null for the first time, the end of\nthe list has been reached.  (The  next()  function will yield null forever\nthereafter.)  Iterators are more efficient than producing the entire list and returning\nit, because the client may be seeking just one particular node in the list,\nand thus producing the entire list so that the client can search just a\nsmall part of it could be wasteful.  There is an analogous function for scopes.   A.iteratorOverScope()  functions like  A.iteratorOverAccessibles() , but\n   walks forwards through the structure, including precisely those nodes for\n   which  B.isInTheScopeOf(A)  holds true.   There are then four functions that use these iterators under the hood.\nClients will most likely wish to use these rather than have direct access\nto the iterators.   A.firstAccessible(P)  expects  P  to be a one-place predicate (that is,\n   a JavaScript function that can be evaluated on a single argument, and\n   yields true or false in each case) and yields the first item on the\n   \"accessibles\" list (as given by  A.iteratorOverAccessibles() ) for which\n    P  yields true.  It returns undefined if there is no such thing.  A.firstInScope(P)  expects  P  to be a one-place predicate, as just\n   defined, and behaves just like  firstAccessible() , except it walks\n   through  A.iteratorOverScope()  instead.  A.allAccessibles(P)  expects  P  as in the previous two functions, and\n   yields all nodes accessible to  A  that satisfy  P , in the same order\n   they would be reported by  iteratorOverAccessibles() .  A.allInScope(P)  expects  P  as in the previous two functions, and\n   yields all nodes in the scope of  A  that satisfy  P , in the same order\n   they would be reported by  iteratorOverScope() .", 
            "title": "Structure hierarchies"
        }, 
        {
            "location": "/api-structures/#structure-attributes-and-connections", 
            "text": "", 
            "title": "Structure attributes and connections"
        }, 
        {
            "location": "/api-structures/#attributes-in-general", 
            "text": "Structures have two types of attributes, computed and external.  The\ndistinction is documented in the source code, here  and here .  The following functions available in each instance of the structure class\nsupport external and computed attributes.   instance.getComputedAttribute(key)  and\n    instance.getExternalAttribute(key)  look up computed or external\n   attributes by a given string  key .  instance.setComputedAttribute(key,value)  and\n    instance.setExternalAttribute(key,value)  store computed or external\n   attributes under a given string  key  with value  value , which should be\n   a JSON structure (or atomic data).  No check is made to verify that the\n   value is of this type, but errors will transpire later if this condition\n   is not satisfied (specifically, serialization errors).  instance.clearComputedAttributes(key1,key2,...)  and\n    instance.clearExternalAttributes(key1,key2,...)  remove the key-value\n   pairs of computed or external attributes associated with any of the keys\n   passed as parameters.  It is acceptable to pass any number of keys,\n   including just one.  If zero are passed,  all  key-value pairs are\n   removed.  instance.attr(object)  adds all attributes of the given object as\n   external attributes to the instance, and returns the instance itself.\n   This is useful when constructing hierarchies, as follows.       var A = new Structure(\n        ( new Structure() ).attr( { name : 'example structure' } ),\n        ( new Structure() ).attr( { color : '#99ff00' } )\n    );   instance.compute(arguments)  is a useful shortcut for storing computed\n   attributes.  We do not redocument its details here; see the documentation\n   in the source code at the end of\n    this section .", 
            "title": "Attributes in general"
        }, 
        {
            "location": "/api-structures/#connections-as-a-type-of-attribute", 
            "text": "Within a structure's external attributes are two key-value pairs that should\nnot be used for any other purpose, those with keys  connectionsOut  and connectionsIn .  These store data about connections between pairs of\nstructures in the same heirarchy.  The data is stored by structure IDs, so\nmaking connections assumes that structures each have a unique ID, as\ndocumented  below .  You can query the connections among structures with these functions:   source.allConnectionsOut(type)  returns a list of all destinations to\n   which the source is connected by one or more connections of the given\n   type.  Each destination appears on the list a number of times equal to\n   the number of connections of the given type from the source to that\n   destination.  destination.allConnectionsIn(type)  functions analogously to the\n   previous, but for connections into a destination, rather than out from a\n   source.  source.allConnectionsOut()  returns a list of destination-type pairs,\n   all connections that go out from the given source structure.  destination.allConnectionsIn()  functions analogously to the previous,\n   but for connections into a destination, rather than out from a source.  destination.properties()  looks at the set of source structures that\n   connect to the destination via arrows, and forms a dictionary of\n   key-value pairs, the \"properties\" of the destination.  The key will be\n   the type of the connection and the value will be the array of sources\n   that connected to the destination with that connection type.   To create or destroy connections, use these functions:   source.connectTo(destination,type) , where  source  and  destination \n   are  Structure  instances and  type  is a string containing the type of\n   connection, creates a new connection.  There can be multiple connections\n   between the same two structures, even of the same type.  Returns true if\n   the connection was formed, false if some error prevented it (such as the\n   destination not being a structure, or not having an ID, or the source\n   not having an ID).  source.disconnectFrom(destination,type)  undoes the previous operation.\n   Because there may be multiple connections between the source and\n   destination of the same type, this simply decreases that number by one.\n   Returns true on success or false on failure (for example, if there were\n   no connection to delete).   If the  connectionsOut  and  connectionsIn  data is directly manipulated by\nthe client (not recommended), then you can call  root.fillOutConnections() \nto ensure that the connection data stored in every source matches that\nstored in the corresponding destinations, and vice versa.", 
            "title": "Connections as a type of attribute"
        }, 
        {
            "location": "/api-structures/#other-attribute-conventions", 
            "text": "Text:   Some structures contain plain text.  The convention is to store these in the external attribute with key \"text.\"  For convenience, there is a  text()  member function in the structure class that looks up this\n*attribute's value.  References:   Some structures serve as references to other structures. They are marked as references with the external attribute \"reference.\"  For convenience, there is a  isAReference()  member function in the structure class that looks up whether this attribute is present, and thus the structure is functioning as a reference.  Labels:   Get a list of all text values used as labels for a structure by\ncalling its member function  labels() .  There are several ways that a\nstructure can be labeled, all documented in the source code .  All labels are strings.  Check whether a string is on that list with the member function hasLabel(label) .  Reasons and premises:   You can get a list of all reasons or premises\nattached to a structure with the member functions  reasons()  and premises() .  These may be structures or the names by which structures\naccessible to this one are labeled.  There are several ways that a structure\ncan have a reason or premise attached, all documented in the source code .  Citations:   Given a string and a structure  S , you can look up the\nnearest accessible (to  S ) structure that has that string as a label with S.lookup(label) .  We say that one structure cites another if it has that\nother as a reason or premise; you can query this binary relation with structure.cites(other) , and get a list of everything that cites a given\nstructure with  structure.whatCitesMe() .", 
            "title": "Other attribute conventions"
        }, 
        {
            "location": "/api-structures/#unique-ids", 
            "text": "The  Structure  class maintains a mapping from nonnegative integer IDs to\ninstances of the class.  A class, upon construction, doesn't get assigned a\nunique ID by default, but you can request one at any time.  Here are the relevant functions:   instance.ID  contains the instance's ID, if it has one, or undefined if\n   not  instance.getID()  asks the class to allocate a new, unique ID to the\n   instance.  It does nothing if the instance already had an ID.  instance.releaseID()  deletes the ID from the instance and lets the\n   class know that the ID is no longer in use, so that it may be assigned to\n   another instance later  Structure.instanceWithID(id)  takes a nonnegative integer ID and yields\n   the instance with that ID, if there is one, or null or undefined if there\n   is none.   If you have a structure hierarchy in which you wish all nodes to have a\nunique ID installed, call  setup()  on the root, and it will recursively\ncall  getID()  in each instance.  It will also call  fillOutConnections() .", 
            "title": "Unique IDs"
        }, 
        {
            "location": "/api-lde/", 
            "text": "API Documentation for the LDE Module\n\n\nThis document is a placeholder, and will be filled in later.", 
            "title": "The LDE"
        }, 
        {
            "location": "/api-lde/#api-documentation-for-the-lde-module", 
            "text": "This document is a placeholder, and will be filled in later.", 
            "title": "API Documentation for the LDE Module"
        }
    ]
}